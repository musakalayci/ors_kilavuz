
<!DOCTYPE html>

<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Örs Kılavuz</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="Dizin" href="genindex.html" />
    <link rel="search" title="Ara" href="search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="tr">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="#">
      
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p class="caption" role="heading">
 <span class="caption-text">
  İçerik:
 </span>
</p>
<ul class="nav bd-sidenav">
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/musakalayci/ors"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <p class="caption" role="heading">
 <span class="caption-text">
  İçerik:
 </span>
</p>
<ul class="visible nav section-nav flex-column">
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/giris">
   Giriş
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/onsoz">
     Hedefler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/tanıtım">
     Tanıtım
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#neden-yeni-bir-yazilim-dili">
     Neden yeni bir yazılım dili ?
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#ors-tasarim-ilkeleri">
     Örs tasarım ilkeleri
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/kurulum">
     Kurulum
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/derleme">
     Derleme
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/hızlı_tanıtım">
   Tanıtım
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/lügat">
     Lügât
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/yorumlar">
     Yorumlar
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/degerler">
     Değerler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/ifadeler">
     İfadeler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/satırlar">
     Satırlar
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/hafıza">
     Hafıza
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/islemler">
     İşlemler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/turler">
     Türler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/birimler">
     Birimler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/yine_yeniden_islemler">
     Yine Yeniden İşlemler:
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/acemi_ocagı">
   Acemi Ocağı
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/algoritmalar">
   Algoritmalar
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/unix_ortami">
   Unix Ortamı
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/tasarım">
   Tasarım
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Örs Yazılım Dili Kullanım Kılavuzu</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <p class="caption" role="heading">
 <span class="caption-text">
  İçerik:
 </span>
</p>
<ul class="visible nav section-nav flex-column">
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/giris">
   Giriş
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/onsoz">
     Hedefler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/tanıtım">
     Tanıtım
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#neden-yeni-bir-yazilim-dili">
     Neden yeni bir yazılım dili ?
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#ors-tasarim-ilkeleri">
     Örs tasarım ilkeleri
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/kurulum">
     Kurulum
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/giris/derleme">
     Derleme
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/hızlı_tanıtım">
   Tanıtım
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/lügat">
     Lügât
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/yorumlar">
     Yorumlar
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/degerler">
     Değerler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/ifadeler">
     İfadeler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/satırlar">
     Satırlar
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/hafıza">
     Hafıza
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/islemler">
     İşlemler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/turler">
     Türler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/birimler">
     Birimler
    </a>
   </li>
   <li class="toctree-l2 toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="index.html#document-bolumler/tanıtım/yine_yeniden_islemler">
     Yine Yeniden İşlemler:
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/acemi_ocagı">
   Acemi Ocağı
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/algoritmalar">
   Algoritmalar
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/unix_ortami">
   Unix Ortamı
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="index.html#document-bolumler/tasarım">
   Tasarım
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="ors-yazilim-dili-kullanim-kilavuzu">
<h1>Örs Yazılım Dili Kullanım Kılavuzu<a class="headerlink" href="#ors-yazilim-dili-kullanim-kilavuzu" title="Bu başlık için kalıcı bağlantı">#</a></h1>
<div class="toctree-wrapper compound">
<span id="document-bolumler/giris"></span><section id="giris">
<h2>Giriş<a class="headerlink" href="#giris" title="Bu başlık için kalıcı bağlantı">#</a></h2>
<div class="toctree-wrapper compound">
<span id="document-bolumler/giris/onsoz"></span><section id="hedefler">
<h3>Hedefler<a class="headerlink" href="#hedefler" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<section id="egitim-hedefleri">
<h4>Eğitim hedefleri:<a class="headerlink" href="#egitim-hedefleri" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Örs dilinin nasıl çeşitli yazılımları hazırlamakta verimli ve etkili bir şekilde kullanılacağına dair kullanım kılavuzu hazırlanması.</p>
<p>Orta sınıf öğrencilerin ve üstünün matematik ve bilgisayar bilimlerindeki doğal terimlerle aşina edilmesi.</p>
<p>Doğal terimlerle hazırlanmış, elaltı tasarım ilkesine uyan yazılım arayüzü e ilgili yazılım kütüphanelerinin ve kullanım kılavuzlarının hazırlanması.</p>
<p>Çeşitli vidyo paylaşım sitelerinde yazılımın temelleri, algoritmalar, bilgisayar bilimleri ve terimleri ile alakalı, herşeyden önce aşina olmayana yönelik eğitim vidyoları ve kısa tanıtım dizilerinin hazırlanması.</p>
<p>Dilin orta okul, lise ve üniversite denginde eğitimleri için derste okutulabilir kitabının yazılması.</p>
<p>Gençlerimizin yazılım keyfini tatmaları, onlara ileri seviye bir kavram olan ama temel bir yeti olan yazım mimarisi kavramının üstü kapalı olarak aşılanması için oyun motoru hazırlanması.</p>
<p>Çocuk ve gençlerimize temel seviye bilişim okur yazarlığı için dağınık olan kaynakların uzmanlarınca bir araya getirilmesi ve onların bilgi işlem başıbozukluğundan kurtarılması.</p>
<p>Bilgisayar, matematik, mühendislik konularında açık kaynak, yani uzmanların tartışmasına ve katkısına açık, bir terimler ve deyimler sözlüğü oluşturulması.</p>
</section>
<section id="altyapi-hedefleri">
<h4>Altyapı Hedefleri<a class="headerlink" href="#altyapi-hedefleri" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Windows, Unix ailesi işletim sistemleri ile iletişim kuracak arayüzlerin hazırlanması.</p>
<p>Hiç değilse insan yetiştirmek amacı güden işletim sistemi çekirdeği yazmak.</p>
<p>Hiç değilse insan yetiştirmek amacı güden dosya sistemi yazılımları ve algoritmaları üzerine çalışma yapmak.</p>
<p>Örs yazılım dili söz dizimi ile uyumlu, Microsoft C# Linq tasarımını ilkelerine sadık, SQL, NOSQL veritabanı ağ arayüzleri ile iletişim kurabilen veritabanı dili geliştirilmesi.</p>
<p>İşletim sistem ile iletişim kurmaya yarayan ingilizce “shell” denilen, Örs dili tasarım ilkelerine, yani sadelik, anlaşılabilirlik, okunabilirlik, basitlik, sadık metin arayüzünün geliştirilmesi</p>
<p>Bir sistem yazılımı dili olan Örs’ün aksine nesne tabanlı, işlevsel (yani lamda ifadelerine doğal destek veren), çeşitli yazılım ortamlarında çalışabilecek, piyasadaki alanda iş yapan şirketlerin üretkenliğini arttıracak bir yazılım dili daha tasarlanması.</p>
<p>Unix ailesi işletim sistemleri hakkında bilinçlendirme, farkındalık çalışmaları yapmak. Bu konuda çeşitli yayınlar hazırlamak.</p>
</section>
<section id="turkce-hedefleri">
<h4>Türkçe hedefleri<a class="headerlink" href="#turkce-hedefleri" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Dilimizin kısır, işlevsiz, kulağa çirkin gelen plaza diline karşı elini güçlendirmek. Sadece bu herşeye değer.
Kurumsal hedefler:</p>
<p>Yukarıdaki hedeflere sadık kalacak, eğitim odaklı vakıf kurmak.</p>
</section>
<section id="faydalar">
<h4>Faydalar<a class="headerlink" href="#faydalar" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Bilgi işlem düzenekleri tasarımı konusundaki eğitim sınırını orta okula kadar çekmek fazlasıyla mümkün.</p>
</section>
<section id="iletisim">
<h4>İletişim<a class="headerlink" href="#iletisim" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Herhangi bir sorunla karşılaştığınızda <a class="reference external" href="mailto:musakalayci&#37;&#52;&#48;gmail&#46;com">musakalayci<span>&#64;</span>gmail<span>&#46;</span>com</a> adresine bildirebilirsiniz.</p>
</section>
</section>
<span id="document-bolumler/giris/tanıtım"></span><section id="tanitim">
<h3>Tanıtım<a class="headerlink" href="#tanitim" title="Bu başlık için kalıcı bağlantı">#</a></h3>
</section>
<section id="neden-yeni-bir-yazilim-dili">
<h3>Neden yeni bir yazılım dili ?<a class="headerlink" href="#neden-yeni-bir-yazilim-dili" title="Bu başlık için kalıcı bağlantı">#</a></h3>
</section>
<section id="ors-tasarim-ilkeleri">
<h3>Örs tasarım ilkeleri<a class="headerlink" href="#ors-tasarim-ilkeleri" title="Bu başlık için kalıcı bağlantı">#</a></h3>
</section>
<span id="document-bolumler/giris/kurulum"></span><section id="kurulum">
<h3>Kurulum<a class="headerlink" href="#kurulum" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<p>Gerekli yazlımlar:</p>
<section id="freebsd-icin">
<h4>Freebsd için<a class="headerlink" href="#freebsd-icin" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pkg install llvm<span class="o">[</span><span class="m">10</span>+<span class="o">]</span> clang<span class="o">[</span><span class="m">10</span>+<span class="o">]</span> python<span class="o">[</span><span class="m">3</span>+<span class="o">]</span> cmake<span class="o">[</span><span class="m">3</span>+<span class="o">]</span> git
</pre></div>
</div>
<p>Tercihen valgrind kurabilirsiniz.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pkg install valgrind
</pre></div>
</div>
<p>Eğer freebsd’de clang atfı yoksa:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln -s /usr/local/bin/clang<span class="o">[</span><span class="m">10</span>+<span class="o">]</span> /usr/local/bin/clang
</pre></div>
</div>
<p>Eğer python atfı yoksa:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln -s /usr/local/bin/python<span class="o">[</span><span class="m">3</span>+<span class="o">]</span> /usr/local/bin/python
</pre></div>
</div>
</section>
<section id="linux-icin">
<h4>Linux için<a class="headerlink" href="#linux-icin" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Pacman yazılımı kullanan Arch Linux türevleri için:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pacman -Syu llvm clang python<span class="o">[</span><span class="m">3</span>+<span class="o">]</span> cmake git
</pre></div>
</div>
<p>Ubuntu ve Debian türevleri için:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>apt install llvm clang python<span class="o">[</span><span class="m">3</span>+<span class="o">]</span> cmake git
</pre></div>
</div>
<p>Gerekli yazılımlar yüklendikten sonra</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git clone  https://github.com/musakalayci/ors.git
<span class="gp">$ </span><span class="nb">cd</span> ors
<span class="gp">$ </span>./baslat.py -d
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Uyarı</p>
<p>Eğer ki eğer ‘baslat.py’ belgesi çalıştırılamıyorsa</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>chmod -x ./baslat.py
</pre></div>
</div>
<p>komutu ile belgeyi çalıştırılabilir hale getirmelisiniz.</p>
</div>
<p>Yukarıdaki komutlar ile örs derleyicisini C derleyicisine derlettirip kurabilirsiniz.
LLVM arayüzünün çalıştığı her ortamda Örs kullanılabilir hale gelecektir.
Şuan itibari ile Örs kaynak kodu C dilinden oluşuyor ama Örs beta aşamasına geçtiğinde
kendi kendisini derleyecek yetiye sahip olacaktır ve ilk sürümde
hem derleyicinin dili hem de ortamının örtüşmesi sağlanacaktır.</p>
</section>
</section>
<span id="document-bolumler/giris/derleme"></span><section id="derleme">
<h3>Derleme<a class="headerlink" href="#derleme" title="Bu başlık için kalıcı bağlantı">#</a></h3>
</section>
</div>
<div class="admonition warning">
<p class="admonition-title">Uyarı</p>
<p>Daha hala hazırlık aşamasındayız. Bu illaki kötü bir şey olacak
diye bir kaide yok. Eğer yapıcı eleştirilerinizi iletirseniz
hazırlık aşamasında katkıda bulunabilir ve Örs dilinin gelişimine
kendi isteklerinizi de ekleyebilirsiniz.</p>
<p>İletişim için <a class="reference external" href="mailto:musakalayci&#37;&#52;&#48;gmail&#46;com">musakalayci<span>&#64;</span>gmail<span>&#46;</span>com</a> adresine yazarsanız, konusunu
belirtirseniz eleştirilerinizi mümkün olduğunca dikkate alabilirim.</p>
<p>Hatta önerileriniz varsa iletişim kanallarını açık tutarız ve
beraber sorunlara çözümler geliştirebiliriz.</p>
<p>Uslu çocuk olursak şirinleri bile görebiliriz.</p>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Arama Sayfası</span></a></p></li>
</ul>
</section>
<span id="document-bolumler/hızlı_tanıtım"></span><section id="tanitim">
<h2>Tanıtım<a class="headerlink" href="#tanitim" title="Bu başlık için kalıcı bağlantı">#</a></h2>
<div class="toctree-wrapper compound">
<span id="document-bolumler/tanıtım/lügat"></span><section id="lugat">
<h3>Lügât<a class="headerlink" href="#lugat" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<p>İkinci şahıslar tarafından kullanılamayacak
kelimeler her yazılım dilinde olduğu gibi Örs’de de var.
Bunlar yazılım dilini oluşturan söz dizisine dahil oldukları için diğer kullanımlara kapalıdırlar.</p>
<dl class="simple">
<dt>Birimler:</dt><dd><ul class="simple">
<li><p>birim, dahili</p></li>
</ul>
</dd>
<dt>İşlemler:</dt><dd><ul class="simple">
<li><p>iş, sanal,</p></li>
</ul>
</dd>
<dt>Birim Erişim:</dt><dd><ul class="simple">
<li><p>küresel, bölgesel, yerel, yaban</p></li>
</ul>
</dd>
<dt>İfadeler:</dt><dd><ul class="simple">
<li><p>evet, hayır, doğru, yanlış, boş</p></li>
</ul>
</dd>
<dt>Karşılaştırma:</dt><dd><ul class="simple">
<li><p>ve, ya_da, veya, veyâ</p></li>
</ul>
</dd>
<dt>Yapıtaşları:</dt><dd><ul class="simple">
<li><p>eh</p></li>
<li><p>t8, harf, t16, t32, t64, t128, tam</p></li>
<li><p>d8, simge, d16, d32, d64, d128, doğal</p></li>
<li><p>o32, o64, o128, ondalık</p></li>
<li><p>şey, mimari, metin</p></li>
</ul>
</dd>
<dt>Türler:</dt><dd><ul class="simple">
<li><p>tür, ortak, kalıp, sayaç</p></li>
</ul>
</dd>
<dt>Satırlar:</dt><dd><ul class="simple">
<li><p>değer</p></li>
<li><p>git</p></li>
<li><p>eğer, eğer ki, değilse</p></li>
<li><p>tüm, her, devam, son</p></li>
<li><p>durum, seçim, varsayılan, tekrar, geç,</p></li>
<li><p>dön</p></li>
</ul>
</dd>
<dt>Hafıza:</dt><dd><ul class="simple">
<li><p>yeni, temiz, yenile</p></li>
<li><p>sil, boşalt, doldur</p></li>
</ul>
</dd>
</dl>
</section>
<span id="document-bolumler/tanıtım/yorumlar"></span><section id="yorumlar">
<h3>Yorumlar<a class="headerlink" href="#yorumlar" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<p>Örs dilinde yorumlar C ailesi söz dizimi kuralını uygular.</p>
<dl class="glossary">
<dt id="term-Tek-Satirli">Tek Satırlı:<a class="headerlink" href="#term-Tek-Satirli" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">Toplama</span> <span class="n">işlemi</span> <span class="n">için</span> <span class="n">tek</span> <span class="n">satır</span> <span class="n">yorum</span> <span class="n">örneği</span><span class="o">.</span>
<span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">:</span> <span class="n">tam</span> <span class="o">=&gt;</span>
  <span class="n">dön</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="o">//</span><span class="n">tek</span> <span class="n">satırlı</span> <span class="n">yorum</span><span class="o">.</span>
</pre></div>
</div>
<p>Tek satırlı yorumlar için ‘//’ simgesi ile başlanıp yeni <em>metin satırında</em> biter.
Burada altını çizmek isterim metin satırları yani ‘/n’ ile simgelendirdiğimiz ascii
kodu ‘0x0A’ olan kavram ile Örs derleyicisinin satırlardan anladığı şey bambaşka şeylerdir ve
kesinlikle karıştırılmamalıdır. Bu konuya satırlar konusunda değineceğiz.</p>
</dd>
<dt id="term-Cok-Satirli">Çok Satırlı:<a class="headerlink" href="#term-Cok-Satirli" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span>
  <span class="n">Toplama</span> <span class="n">işlemi</span> <span class="n">için</span>
  <span class="n">çok</span> <span class="n">satırlı</span> <span class="n">yorum</span> <span class="n">örneği</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">:</span> <span class="n">tam</span> <span class="o">=&gt;</span>
  <span class="n">dön</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="o">//</span><span class="n">tek</span> <span class="n">satırlı</span> <span class="n">yorum</span><span class="o">.</span>
</pre></div>
</div>
<p>Çok satırlı yorumlar için ‘/*’ simgesi ile başlanıp ‘*/’ bitirilir.</p>
</dd>
<dt id="term-Kilavuz">Kılavuz:<a class="headerlink" href="#term-Kilavuz" title="Permalink to this term">#</a></dt><dd><p>Yorumlar kavram olarak yazılımcıların çalışırken ilk önce
kendi kendilerine tuttukları notlar olarak değerlendirilebilir. O yüzden derleyici ‘.ors’ belgesindeki yorumları anlamlandırmaz ve çözümleme aşamasında geçilir.</p>
<p>Tabi ki de faydaları tartışılamaz ama kılavuz üretiminde kullanışlı değillerdir.
Alakalı önemi ise Örs doğasında açık kaynak destekleyen bir dil ve kılavuzu yazılmamış
açık kaynak yazılımların piyasada bir önemi olmamaktadır. Bu yönüyle Örs dilinin kılavuz
yetenekleri en az yazılımdaki yetenekleri kadar önemlidir. Çünkü diğer mühendislerin
okuyup anlayamadığı ve dolayısıyla kullanamadığı kodun açık kaynak dünyasında pek yaşama
şansı yoktur.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">*</span>
  <span class="n">kılavuz</span><span class="p">::</span><span class="n">örnek_kütüphane</span><span class="p">::</span><span class="n">Topla</span> <span class="o">+=</span>
    <span class="n">tanıtım</span><span class="p">:</span> <span class="s2">&quot;Tam sayılar için toplama işlemi yapar&quot;</span><span class="p">,</span>
    <span class="n">değişkenler</span><span class="p">:</span> <span class="p">{</span><span class="o">...</span><span class="p">},</span>
    <span class="n">örnek</span><span class="p">:</span> <span class="s2">&quot;x := 22;</span><span class="se">\\</span><span class="s2">n</span>
            <span class="n">y</span> <span class="o">:=</span> <span class="mi">33</span><span class="p">;</span>\\<span class="n">n</span>
            <span class="n">z</span> <span class="o">:=</span> <span class="n">Topla</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="s2">&quot;;</span>
<span class="o">*</span><span class="p">}</span>
<span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">:</span> <span class="n">tam</span> <span class="o">=&gt;</span>
  <span class="n">dön</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte olduğu gibi kılavuz açmak için ‘{*’ simgesi ile başlanır;
kılavuz öğesi yazılır ve ‘*}’ simgesi ile kapatılır.</p>
<p>Kılavuz hazırlama konusunu daha ayrıntılı bir şekilde kılavuz bölümünde ele alacağız.</p>
</dd>
<dt id="term-Kaideler">Kaideler:<a class="headerlink" href="#term-Kaideler" title="Permalink to this term">#</a></dt><dd><p><strong>Yorumlar derleyici tarafından satırmış gibi algılanır.</strong>
O yüzden ifadeler arasında yorum bulunamaz. Yani aşağıdaki örnek
Örs derleyicisi tarafından reddedilecektir.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="o">//</span><span class="n">bir</span> <span class="n">takım</span> <span class="n">şeyler</span>
  <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Kılavuz yorumları sadece 'birim'lerde yer alabilir.</strong>
Zira işlem bedenlerinde kılavuzun anlamı yoktur. Bu bağlamda kılavuz yorumları
birim’lere dahil edilir.</p>
</dd>
</dl>
</section>
<span id="document-bolumler/tanıtım/degerler"></span><section id="degerler">
<h3>Değerler<a class="headerlink" href="#degerler" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<p>Özlerinde amacı bir takım veriler üretmek olan yazılımların başlangıç ve sonuçlarını
saklamak için değer kavramına ihtiyacımız var.
Bu konuda çeşitli tartışmalar ve aşırıya kaçan çözümler olsa da Örs,
C dillerinden yani bilgisayarın kalbine doğrudan erişimi olan
dillerden olduğu için, tanımlı tüm değerlerin bilgisayar belleğinde fiziki konumu vardır ve
bu konum sanal yollardan erişilebilir.</p>
<p>Örs’de söz dizimi farkıyla iki türlü değer tanımı yapılabilir. Açık ve Pascal tanımı.</p>
<dl class="glossary">
<dt id="term-Acik-tanim">Açık tanım:<a class="headerlink" href="#term-Acik-tanim" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">sayı</span>        <span class="n">tam</span><span class="p">;</span><span class="o">.</span>
<span class="n">değer</span> <span class="n">_birşeyler</span>  <span class="n">metin</span><span class="p">;</span>
<span class="n">değer</span> <span class="n">_utf_metni</span> <span class="o">*</span><span class="n">t8</span><span class="p">;</span>

<span class="n">değer</span> <span class="n">yaşım</span> <span class="n">tam</span>     <span class="o">=</span> <span class="mi">29</span><span class="p">;</span>
<span class="n">değer</span> <span class="n">_mahmut</span> <span class="n">metin</span> <span class="o">=</span> <span class="s2">&quot;Ikinci Mahmut&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Burada söz diziminden anlaşılacağı üzere “değer” kelimesi ile değer tanımlandığı
tetiklenir, sonrasında değerin benzersiz ismi gelir, sonrasında ise değerin türü.
Değer tanımlamak için bu kadarı yeterlidir ama bu şekliyle değerlerin ilk değerleri
belirlenmemiştir. Dolayısıyla bu değerlerin hafızada tuttuğu veriye ulaşıldığında
elimize ne geçeceğini bilemeyiz. O yüzden isteğe bağlı olarak, yukarıda olduğu gibi, değerler “=” simgesi
ile başlatılabilir.</p>
</dd>
<dt id="term-Pascal-tanimi">Pascal tanımı:<a class="headerlink" href="#term-Pascal-tanimi" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gelen</span>   <span class="o">:=</span> <span class="n">belge</span><span class="p">::</span><span class="n">aç</span><span class="p">();</span>
<span class="n">yaşım</span>   <span class="o">:=</span> <span class="mi">29</span><span class="p">;</span>
<span class="n">_mahmut</span> <span class="o">:=</span> <span class="s2">&quot;İkinci Mahmut&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Pascal tanımlarda ise değerin ilk değerinin olduğu varsayılır.
Bu yönüyle tanımın türü en baştan bellidir ve diğer söz dizileri gereksiz kalır.
Tasarım amacı okunmayı kolaylaştırmaktır.
Görsel kullanışlılığı dışında tüm fiziki, yani bilgisayarın gördüğü,
özellikleri “değer” kavramı ile aynıdır. İsmini ise Pascal yazılım dilinden alır.
Çeşitli yazılım dillerinde Pascal tanım satırını görebilirsiniz.</p>
</dd>
</dl>
</section>
<span id="document-bolumler/tanıtım/ifadeler"></span><section id="ifadeler">
<h3>İfadeler<a class="headerlink" href="#ifadeler" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<div class="toctree-wrapper compound">
<span id="document-bolumler/tanıtım/ifadeler/boş"></span><section id="bos">
<h4>Boş<a class="headerlink" href="#bos" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Sayılar için 0 değerini; türler için sıfırlanmış üyeleri;
konumlar için ise yokluğu tanımlayan
saf ifadelerdir. Yani saf halleriyle daha anlamlıdırlar.
Anlamları üretim sürecinde yorumlanır.</p>
<p>C dilindeki ‘void’ değillerdir ve bu yönüyle ‘*boş’ gibi bir ifade
hata verir zira olmayan konumun değerini nasıl alacaksınız.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">değer</span> <span class="n">j</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">değer</span> <span class="n">k</span> <span class="n">tam</span> <span class="o">=</span> <span class="n">boş</span><span class="p">;</span>
</pre></div>
</div>
<p>Örnekteki tanımlı değerlerin hepsinin içeriği 0’dır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tür</span> <span class="n">ikili</span>
<span class="p">{</span>
  <span class="n">a</span> <span class="n">tam</span><span class="p">;</span>
  <span class="n">b</span> <span class="n">tam</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">iş</span> <span class="n">Örnek</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">a_ve_b</span> <span class="n">ikili</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="n">değer</span> <span class="n">b_ve_a</span> <span class="n">ikili</span> <span class="o">=</span> <span class="n">boş</span><span class="p">;</span>
  <span class="o">//</span><span class="n">sıradaki</span> <span class="n">ise</span> <span class="n">hata</span> <span class="n">verir</span><span class="p">;</span>
  <span class="n">değer</span> <span class="n">hatalı</span> <span class="n">ikili</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Örnek işleminin ilk iki satırında ‘ikili’ türündeki değer yaratılır ama
içeriği sıfırlanmıştır. Üçüncü satırda ise hata alacağız çünkü ikili türünün
içeriğinde sayı yapıtaşları olsa da kendisi sayısal yapıtaşı değildir.</p>
</section>
<span id="document-bolumler/tanıtım/ifadeler/sayı"></span><section id="sayilar">
<h4>Sayılar<a class="headerlink" href="#sayilar" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Bilgisayar dünyasındaki tüm veri türleri
en sade haliyle ifade edilmiş sabit değerlerdir.
Sabitlerdir ve bir değere atanıncaya kadar yaşadıkları konumları yoktur.</p>
<p>Şimdi biraz hayal edin. 16 bit genişliğinde veri türü tanımladığınızda aslında yaptığınız şey;
2^16 farklı birim tanımlamaktır. Çünkü sayılar deyince ortalama bir insanın aklına hesap gelebilir
ama bizim için en önemli anlamı bu sayıların etiket gibi kullanılabilecek olmasıdır. Mesela ilk okul
numaram 115’di. 115 numarası okul ortamında bana atıfta bulunuyordu. Işte bu yönüyle katı tanımlı sayı
türlerinin varlığı sayısal tasarımda anlam kazanıyor. Veritabanlarından, işletim sistemlerine,
devlet dairelerindeki belgelerden, okullara kadar her yerde var olan basit bir anlam. O da basitçe
özlerinde birer atıflar olmalarıdır. Yani tanımladığımız benzersiz sayılar
benzersiz nesne ya da öznelere atıfta bulunurlar.</p>
<p>Örs’de tanımlı tüm sayı yapıtaşları C, C++ dilleri ile llvm aracılığı ile tam uyumludur.
Zira öyle olmak da zorundadır. Çünkü yazılım dilleri uzayın derinliklerinde yalıtılmış
ortamlarda yaşamıyor. Aksine milyonlarca farklı birimle iletişim halindeler ve bu iletişimi
kayıpsız yapabilmenin en basit yolu, tüm dillerde kullanılabilecek sade, bitlerle tanımlabilecek,
türlerden geçmektedir. Zaten “dijital tasarım” denilen kavramın özü de tam olarak burasıdır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*pascal haliyle:*/
atmışDörtBitlikTamSayı := 55_st64;
uzunSayılar            := 10_000_000_st32;  /*fark ettiyseniz alt tirelerin yerinin bir önemi yok*/
okulNo                 := 2004_43_280_st32; /*mesela*/
yaşım                  := 29;               /*t32 varsayılır*/
oran32                 := 44.00_o32;
oran                   := 12.88             /*o64 varsayılır ve ondalık kısım nokta ile ayrılır*/;

/*açık haliyle*/
değer uzun d64   = 11_000_000;
değer uzun64 d64 = 22_999_000_sd64; /*Aynı şey mi ? Evet. Peki ya sıradaki:*/
değer u64 d64    = 22_990_1_st32; /*u64 değeri 64 bitlik doğal sayı olarak tanımlanıp atanan sabit değer çevrilir.*/
</pre></div>
</div>
</section>
<span id="document-bolumler/tanıtım/ifadeler/konumlar"></span><section id="konumlar-ve-diziler">
<h4>Konumlar ve Diziler<a class="headerlink" href="#konumlar-ve-diziler" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Sistem dillerinin en çetrefilli ama eğlenceli konusu: Konumlar.</p>
<p>Basitçe hayal edelim; Bir bakkal deposu var ve burada sayılamayacak kadar çok kutu ve
içinde de bir takım abur cuburlar var. Tüm bu kutular numaralanmış ve numaralanmış
raflara yerleştirilmiş. Kim yerleştirdi bilmiyoruz da umursamıyoruz da. Amacımız
bir an önce ‘çuklatalara’ erişmek. İşin güzel yanı laz bakkal bize demiş ki
&quot;Al üzerinde ‘LB 22 543’ yazan bu kağıdı takip et,
dilediğin kadar çuklataya yumul gitsin.&quot;</p>
<p>Ben olsam, kağıttaki bilgiyi yorumlamakla başlardım. Derdim ki,
&quot;Tamam LB laz bakkal demek ve zaten depodayız,
22 ve 543 ise ya raf ya da kutu numarası olamalı.
İlkin 22 numaralı rafla başlayayım uymazsa tersini denerim.&quot;
Basit bir strateji ve elimde bir kutu çuklata var.</p>
<p>Konumlar kunusu da bu örneğe benziyor. Konu çetrefilli çünkü
konumların gösterdiği yerlerde çuklata yok yine bir diğer sayı var. Eğlenceli
çünkü o sayı her anlama gelebilir.
Mesela veri tabanındaki en sevdiğimiz çuklata kutusunun depodaki konumunu verebilir
ya da o konumda komik vidyo adresi olabilir yani herşey olabilir.
Örs dilinde tabi ki de konumlar diye bir özellik yok;
hatta diğer sistem dillerinde de yok ama kavram hem sanal dünyada hem de gerçek dünyada
temel bir konu olarak yer aldığı gibi Örs’de dahil tüm sistem dillerinde yer alıyor.</p>
<p>Sadece Örs değil diğer sistem dillerinde de konum kavramı bir soyutlamadır.
Özlerinde mimari boyutunda doğal sayılardır.
Mesela 64 bitlik işlemcideki konumlar da 64 bit genişliğindedir ve bu konumlar basitçe bilgisayar
hafızasındaki 64 bitlik hücrelerin numaralarıdır.</p>
<p>Düz mantıkla bilgisayar belleği uç uca dizilmiş boncuklar dizisi gibi düşünülebilir. Mesela
benim 64 bitlik bilgisayarın 8gb hafızası var ve bu <strong>düz mantıkla</strong> 0’dan (8gb/8)’e kadar
numaralanmış 8 bitlik boncuklar var ve benim öyle bir kavrama ihtiyacım var ki ihtiyaç halinde
bu boncuklara ulaşıp içindekini alayım.</p>
<p>Bu kavram konumlar oluyor. Bir önceki <strong>düz mantık</strong> örnekte gerçek konumlar var.
Yukarıdaki Laz Bakkal örneğinin aksine elimizde doğrudan değeri gösteren doğrusal konum var.
Gerçekte olan şey ise daha karmaşık.
İşletim sistemi belleği bölgelere ayırıyor ve bu bölgeleri işlemler ihtiyaç duyduğunda onlara atıyor.
Yani siz bir konumda bulunan değere ulaşmak istediğinizde önce işletim sisteminin yazılımıza atadığı bölgeye,
sonra değere ulaşıyorsunuz ve bu ucu açık kavrama sanal konum deniyor ki yukarıdaki Laz Bakkal örneğinde,
elimizdeki kağıtta yazan konum sanal bir konum.</p>
<p>Örs konumlar konusunu C dilindeki gibi ve Java, C#, OCaml gibi dillerin aksine, yorumsuz ele alır.
Zira zaten işletim sistemi sanal konum vereceği için bunun üzerine bir algoritma daha eklemek
yazılımın hızını azaltır. Böylece işletim sisteminin bize ayırdığı bölüme doğrudan erişim sağlanabilir.
Bu kulağa hoş gelse de aynı zamanda olabildiğince tehlikelidirde.
Diğer taraftan konumları yorumlamadan ele almak
Örs’ün tasarım ilkeleriyle de çelişmez. Örs’ün tasarım felsefesi bu ve benzeri olaylara
&quot;eğer bir hata verilecekse bırakalım verilsin&quot; yargısıyla yaklaşır.
Çünkü konumlarla ilgili hatalar konumların doğrudan erişim
yeteneğinden ziyade, hafıza yetersizliği, sıralama yanlışlığı,
atanan bölge dışına taşma, boş konum ve benzeri sorunlardan kaynaklanır
ve benzeri hatalar yazılımın hata ayıklama sürecinde engellenebilir ki
yukarıdaki yargının atıfta bulunduğu anlam da budur.
Bu yönüyle konumlarla ilgili olası tehlikeler yazılımcının sorumluluğundadır ve
ne işletim sisteminin ne de sistem dillerinin sorumluluğunda değildir.</p>
<p>Örs dilinde ve diğer sistem dillerinde konumlar <strong>‘mimari’</strong>
bayt genişliğinde yapıtaşlarıdır. Bu özelliğe atıfta bulunmak
<strong>‘şey’</strong> yapıtaşının kavramsal görevlerinden de bir tanesidir.</p>
<p>Örs konumları kullanmak için C söz dizisinden yararlanır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">KonumÖrneği</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">a</span> <span class="n">t64</span> <span class="o">=</span> <span class="mh">0x0_47_46_45_44_43_42_41</span><span class="p">;</span>
  <span class="n">değer</span> <span class="n">K</span> <span class="o">*</span><span class="n">t64</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="o">//</span> <span class="n">a</span><span class="s1">&#39;nın konumunu K&#39;</span><span class="n">ye</span> <span class="n">geçiriyoruz</span><span class="o">.</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
    <span class="s2">&quot;a: 0x%llx</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;a&#39;nın konumu: %p</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;K: 0x%llx</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;K&#39;nın konumu: %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">a</span><span class="p">,</span> <span class="o">//</span> <span class="n">a</span> <span class="n">değeri</span>
    <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">//</span> <span class="n">a</span><span class="s1">&#39;nın konumunun alındığı ifade</span>
    <span class="o">*</span><span class="n">K</span><span class="p">,</span> <span class="o">//</span> <span class="n">K</span><span class="s1">&#39;deki konuma gidildiği ifade</span>
    <span class="n">K</span><span class="p">);</span> <span class="o">//</span> <span class="n">ve</span> <span class="n">K</span> <span class="n">değerindeki</span> <span class="n">konum</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Tabi ki de böyle bir örneği gerçek hayatta pek kullanmazsınız.
İşte tam burada bir kavramı sizinle tanıştırmam gerekiyor: Dereceler.</p>
<hr class="docutils" />
<section id="konum-dereceleri">
<h5>Konum Dereceleri:<a class="headerlink" href="#konum-dereceleri" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">Giriş</span>
<span class="n">argümanSayisi</span>   <span class="n">tam</span><span class="p">,</span>
<span class="n">_argümanlar</span>   <span class="o">**</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="o">//</span><span class="n">argümanları</span> <span class="n">konumlarından</span> <span class="n">yazdır</span><span class="o">.</span>
  <span class="n">her</span> <span class="n">Argüman</span> <span class="o">:=</span> <span class="n">_argümanlar</span><span class="p">;</span> <span class="o">*</span><span class="n">Argüman</span><span class="p">;</span> <span class="n">Argüman</span><span class="o">++</span><span class="p">:</span>
    <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
      <span class="s2">&quot;=&gt; konum değeri: %p, konumdaki değer: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
       <span class="n">Argüman</span><span class="p">,</span>
      <span class="o">*</span><span class="n">Argüman</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıda ise <strong>‘_argümanlar’</strong> değişkeninde harfler
dizisinin dizisinin konumu <strong>Giriş</strong> işlemine verilmiş.</p>
<p>Örnekte görüldüğü üzere <strong>‘_argümanlar’</strong>’ değişkeninin türünde iki yıldız var.
Derece dediğimize göre şunu diyebilir miyiz : &quot;<strong>’_argümanlar’</strong> değişkeni iki derecelidir&quot; ?
Malesef hayır. Değerin yaşadığı konumu saymayı unuturuz. Yani aslında
<strong>‘_argümanlar’</strong> değişkeni 3 dereceli bir değer. Çünkü tüm değişkenler aynı zamanda
birer değer.
Tanımladığınız tüm değerlere ve işlemlere atıfta bulunulurken,
onların fiziki konumlarındaki veri işlem yığınına konulacak.
Özet olarak değerlere olan herbir atfınız için
konuma gidip derecesini düşürüp veriye
öylece erişiliyor.</p>
<p>Bu manada birinci dereceden değerler tüm tanımlı değerler oluyor.
Ayrıca, konum boyutu arttıkça derecesi de artıyor.</p>
<p>Burada elimizde kendi kendini gösteren kavram var.
Biraz kafa karıştırıcı olsa da iletişim kuramının çıkmaz
sokaklarında sıklıkla bu tarz varlıklara rastlanır.</p>
<p>Bu kavramı tanımlama gereği duydum zira hem derleyicide kullanılıyor,
hem llvm altyapısında,
hem de siz aslında farkında olmadan zihninizde zaten o şekilde canlandırıyorsunuz.
Diğer taraftan, kavramı tanımlamak bizi dizinin dizinin disinin dizinin
konumu gibi çirkin anlatım kullanmaktan koruyacak.</p>
<p>Peki derecesi olmayan değer olabilir mi ? Tabi ki de hayır.
Derecesi yoksa yaşadığı konum da yoktur ve yani o değer yoktur.
Olmayan bir değerin derecesi olabilir mi ? Hayır.</p>
<p>Diyelim ki <strong>‘_argümanlar’</strong> değerine ‘**_argümanlar’ ifadesi ile atıfta bulundunuz.
İlkin <strong>‘_argümanlar’</strong>’ın yaşadığı konuma, sonra orada tutulan konumdaki diziye,
sonra ise dizinin ilk harfine gideceksiniz.</p>
<p>Örneğe tekrar dönelim: Elimizde 3 dereceli değer var.
Yani bir dizi konumu var ve o konumda diğer dizilere olan konumlar tutuluyor.
Peki ben bir derece indirsem yani <strong>‘_argümanlar’</strong> değerinin yaşadığı yere gitsem
ve bunu farklı bir değere atayıp konumunu artırarak içteki 2
dereceli dizileri yazdıra bilir miyim ?
Evet ve yukarıdaki örnek tam olarak bunu yapıyor.</p>
<div class="admonition note">
<p class="admonition-title">Not</p>
<p>Tekrar tekrar belirtmek isterim: Tüm değerler zaten bir hafızadaki bir konumda yaşıyor.
Çoğul dereceli değerlerle o konumları her hangi bir değer ile saklayabiliyoruz.</p>
</div>
<p>Fark edeceğiniz üzere konumlar ve diziler birbirleri ile bir şekilde ilişkili ama
sanki ilişkiyi kuracak kavramı bilmiyoruz ki konum kavramının ve dizilerin birbirlerine karıştırılmasında
yatan ana nedenlerden birisi. Konumlar bir kavram. Konumlarla ilgili gerçek olan tek veri
özlerinde doğal sayı değerleri olması ama diziler ise yazılımda en az d64 yapıtaşı kadar gerçek
bir veri türü.</p>
</section>
<section id="diziler">
<h5>Diziler:<a class="headerlink" href="#diziler" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Hafızada sıralı ve ardışık yer alan üyelerinin bir önemi olmaksızın
doğrusal veri yapısına sahip temel türe denilir.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">DiziÖrneği</span>
<span class="p">{</span>
  <span class="n">stdio</span><span class="p">::</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Dizi Örneği:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">değer</span> <span class="n">tekBoyutlu</span> <span class="n">t8</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span>
    <span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">69</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
  <span class="n">değer</span> <span class="n">ikiBoyutlu</span> <span class="n">t8</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
    <span class="p">[[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">66</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">67</span><span class="p">,</span> <span class="mi">68</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">69</span><span class="p">,</span> <span class="mi">70</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">71</span><span class="p">,</span> <span class="mi">0</span><span class="p">]];</span>
  <span class="n">değer</span> <span class="n">üçBoyutlu</span>  <span class="n">t8</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
    <span class="p">[[[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">66</span><span class="p">],</span> <span class="p">[</span><span class="mi">67</span><span class="p">,</span> <span class="mi">68</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mi">69</span><span class="p">,</span> <span class="mi">70</span><span class="p">],</span> <span class="p">[</span><span class="mi">71</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]];</span>
  <span class="n">stdio</span><span class="p">::</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&gt; &#39;</span><span class="si">%s</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">-&gt; &#39;</span><span class="si">%s</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">-&gt; &#39;</span><span class="si">%s</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">tekBoyutlu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="n">ikiBoyutlu</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="n">üçBoyutlu</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Örnekte yapılan şey gayet basit,
<strong>‘tekBoyutlu’</strong> dizisi için <strong>(&#64;tam)*8</strong> kadar;
<strong>‘ikiBoyutlu’</strong> dizisi için <strong>(&#64;tam)*4*2</strong> kadar;
<strong>‘üçBoyutlu’</strong> dizisi için <strong>(&#64;tam)*2*2*2</strong> kadar bayt hafızası
üretim sürecinde ayrılıyor ve dizinin her bir üyesinin içine belirtilen değerler yazılıyor.
Arayüzdeki çıktıdan anlayabiliriz ki; hafızada yaşadıkları konum farklı olsa da konumlardaki veri aynı
ama tür ifadeleri kullanılarak aynı veri derleyiciye farklı yorumlatılmış.
Çünkü üç farklı konumda yaşayan dizinin üçünün de tür bayt genişliği ve sıralaması aynı
ve hafızada 32 bayt yer kaplıyor.</p>
<p>C söz dizisinin aksine Örs’de dizi tür ifadesinin sözdizisi farklıdır.
C’de yukarıdaki <strong>‘üçBoyutlu’</strong> dizisini tanımlamak için <strong>‘[2][2][2]’</strong>
sözdizisini kullanırken; Örs için <strong>‘[2, 2, 2]’</strong> sözdizisini kullanıyoruz.
Nedeni ise yazarken virgül koymanın ele daha yatkın olması.</p>
<p>Peki yukarıdaki <strong>‘tekBoyutlu’</strong> dizisinin derecesi kaç ? İki mi ? Külliyen hayır.
Orada tek dereceli değer var.
Bu değerin içinde sıralı birden fazla değerin olması derecesini arttırmıyor ve
konumlar kavramı ile dizi türünün biz tasarımcıların kafasını karıştırıyor.
Çünkü işletim sisteminden hafıza alanı istediğimizde onu dizi gibi yorumlayabiliyoruz ve
onu en az iki dereceli değerle saklayabiliyoruz. Diğer taraftan diziler ise tek dereceli. Bu nasıl olur ?</p>
<p>Şöyle ki: Varsayalım ki işletim sisteminden doğrusal hafıza alanı istediniz. İşletim sistemi size
tek dereceli değeri verdi ve onu yine tek dereceli konuma sakladınız; etti iki dereceli konum değeri.
Tanımladığınız dizinin ise yaşadığı hafıza alanının yine bir önceki gibi doğrusal olduğunu varsayalım.
Zaten doğrusal bir hafıza alanında tek dereceli olarak tanımlı ve bir değerde saklı; etti bir dereceli dizi değeri.</p>
<p>Anlamsız geliyor olabilir. Bu ayrım o kadar temel ki beyinde oturması yıllar alıyor.
Bu manada sizlerle bir diğer hayati kavramı daha tanıştırmalıyım:</p>
</section>
<hr class="docutils" />
<section id="boyutlar">
<h5>Boyutlar:<a class="headerlink" href="#boyutlar" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Geometrideki ya da doğrusal cebirdeki boyut kavramının yazılıma izdüşümü denilebilir
ama aynısı denemez.
Mesela yukarıdaki <strong>‘_argümanlar’</strong> konumunda harf dizisi matriksi var ve
biz bunun derecesini 2 düşürdüğümüzde (<strong>’**_argümanlar’</strong>);
matriksteki [0,0] hücresindeki harfe erişiyoruz.</p>
<p>Tıpkı nasıl geometride boyutlar var ise konumlarda içlerinde bulundurdukları veriye
göre boyut anlamı kazanır ve işletim sistemi bu veriyi yapılandırılmış vereceği için dizilere erişir gibi erişilebilir.
Bu yönüyle yukadıraki örneği aşağıdaki gibi yazabiliriz:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">Giriş2</span>
<span class="n">argümanSayisi</span>   <span class="n">tam</span><span class="p">,</span>
<span class="n">_argümanlar</span>   <span class="o">**</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="o">//</span><span class="n">argümanları</span> <span class="n">konumlarından</span> <span class="n">yazdır</span><span class="o">.</span>
  <span class="n">her</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argümanSayisi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
      <span class="s2">&quot;=&gt; konum değeri: %p, konumdaki değer: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
       <span class="o">&amp;</span><span class="n">_argümanlar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
        <span class="n">_argümanlar</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bir önceki örnekle özünde aynı şeyi yapıyor ama fark ettiğiniz üzere ‘argümanSayısı’
değeri bizim gezeceğimiz konumları sınırlıyor ve taşma tehlikesinin de önüne geçiyor.
Olmaz ama diyelim ki konumu arttırarak ilerlediğimiz ‘Argüman’ değeri boş konuma denk gelmedi.
O zaman işletim sisteminin yazılıma ayırdığı bölgenin dışına taşacağı için meşhur <strong>‘SIGSEGV’</strong>
hatasını verecek ve 139 kodu ile sonlandırılacak.
Şunu da eklemek gerekir ki; gözlemlerimden çıkardığım sezgisel sonuca göre
pek çok yazılımcı ilk dereceyi unutup boyut ve derece kavramını karıştırıyor.
Kavramları karıştırarak tasarım yapmaya çalışmak da doğal olarak hatalı sonuçlar doğuruyor.
Bunlar göz önünde tutulunca ikinci yöntem daha güvenli.
Ayrıca veri türü doğrusal olarak hem derleyici hem yazılımcı tarafından
daha yapısal yorumlanıyor ve boyutlar derecelerin aksine elle tutup gözle görebileceğimiz bir kavrama
dönüşmeye başlıyor. Doğal olarak tasarım bir kere cisimleşmeye başlayınca; olgunlaşıyor.</p>
<p>Konu konum kavramı iken eklenmesi gereken bir diğer mevzu bu örnekteki ‘i’
değerinin de bir konum olması. Dereceli değerlerle olan farkı dereceli değerler işletim sistiminin
belirlediği standartlara uyarak hafızayı konumlandırıp erişirken;
‘i’ değeri doğrusal yaklaşımla hafızaya erişiyor olması.
Daha önce bahsettiğimiz sıralı numaralı boncuk dizisi örneğindeki konumlandırma yaklaşlaşımı ile
buradaki ‘i’ değerinin yaklaşımı özlerinde aynı ve iki örnekte de doğrusal konumlandırma yapılıyor.</p>
<p><strong>‘Giriş2’</strong> işlemindeki tek fark bu da değil. İkinci örnekteki print’in ikinci argümanı için yer alan
<strong>(&amp;_argümanlar[i])</strong> ifadesinde konum alma işlemi kullanılırken,
öncekinde üçüncü dereceden <strong>(Argüman)</strong> saf ifadesi yer almış ve ayrıca üçüncü argümandaki
<strong>(*Argüman)</strong> ifadesi ise <strong>‘i’</strong> kadar ilerlenmiş konumun tuttuğu değeri dönüyor.
Sanki <strong>‘&amp;’</strong> (konumlandırma işlemi) ile <strong>‘*’</strong> (derecelendirme işlemi) birbirinin
ters işlemi gibi hissediliyor ve yukarıdaki <strong>tanımlı kavramların sınırında</strong>;
evet iki işlem birbirinin tersi oluyor. Konumlandırma işlemi var olan değerin konumunu getirirken; <strong>‘*’</strong>
işlemi var olan dereceli değerin tuttuğu konumun derecesini düşürüp; düşürülen değeri dönüyor.</p>
<p>Ama bu ikisi de tekiller ve biz sıradaki konuma ulaşmak için tutulu konumu
arttırmak ya da azaltmak zorundayız ki yukarıda anlattığımız gibi yan etkileri olan bir yöntem.
Bu bağlamda dizi erişim işlemi gücünü gösteriyor. Dizi erişim işlemiyle, derecelendirme işlemi
benzer görevleri paylaşsalarda aynı işlem değiller ama <strong>konumdaki veriler ardışık</strong>
ise boyut kavramı hafızanın o <strong>ardışık</strong> parçasına diziymiş gibi erişmemizi sağlıyor.
Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">BoyutKavramıÖrneği</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">işletim</span> <span class="n">sisteminden</span> <span class="p">((</span><span class="n">t32</span><span class="s1">&#39;nin boyutu) X 20) bayt kadar</span>
  <span class="o">//</span> <span class="n">hafıza</span> <span class="n">bölgesi</span> <span class="n">istiyoruz</span><span class="o">.</span>
  <span class="n">Sayılar</span> <span class="o">:=</span> <span class="n">yeni</span><span class="p">(</span><span class="n">t32</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
  <span class="o">//</span> <span class="n">işletim</span> <span class="n">sisteminin</span> <span class="n">bize</span> <span class="n">temizlemeden</span>
  <span class="o">//</span> <span class="n">verdiği</span> <span class="n">bölgedeki</span> <span class="n">t32</span><span class="s1">&#39;leri yazdırıyoruz:</span>
  <span class="n">her</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">stdio</span><span class="p">::</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&#39;ıncı pis değer : </span><span class="si">%d</span><span class="s2">; konumu : %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
      <span class="n">i</span><span class="p">,</span> <span class="n">Sayılar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Sayılar</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="o">//</span> <span class="n">işimizi</span> <span class="n">bitirdik</span> <span class="n">ve</span> <span class="n">bize</span> <span class="n">atanan</span> <span class="n">hafıza</span> <span class="n">bölgesini</span>
  <span class="o">//</span> <span class="n">işletim</span> <span class="n">sistemine</span> <span class="n">geri</span> <span class="n">veriyoruz</span><span class="o">.</span>
  <span class="n">sil</span> <span class="n">Sayılar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Derecelendirme işleminin soyutluğu; erişim işlemi ile kayboluyor ve
biz zihnimizde işletim sisteminden gelen bölgenin aslında bildiğin t32’li boncuklar dizisi
olduğunu canlandırmaya başlıyoruz ve bu noktada konumlar ve dizilerin birbirleri ile ilişkisi
belirmeye başlıyor.</p>
<div class="admonition note">
<p class="admonition-title">Not</p>
<p>Peki şu vaka ile karşılaşabilir miydik ? Biz işletim sisteminden yeni bölge istedik ama
gelen bölgedeki verilerin konumları ardışık değil. Linux ve Freebsd’de kesinlikle öyle değil ama diyelim ki
öyle biz nasıl dereceler kavramını kullanarak ileri, geri konum aritmetiği yapacaktık ?
Basitçe söyleyeyim yapamayacaktık. Eğer veri ardışık değilse zaten konum aritmetiği yapmanın
ne anlamı ve güvenilirliği var. Fakat boyutlar ile dereceler ve konumlar ile diziler arasındaki
kavram ilişkisi devam edecekti. Yine konumlara derecelendirerek erişecektik ve yine dizilere
boyutlandırarak erişecektik. Sadece dereceli erişim yavaş olacaktı ki konum erişimi destekleyen
canlı dillerde (C#, OCaml vs) konum erişimi yavaş olacaktı.
Çünkü işletim sistemi ile sizin yazılımınız arasında hafıza yönetimi yapan temizlik algoritması var
ve her konuma eriştiğinizde zaten işletim sisteminin sanal olan konumlarını bir de temizlik algoritmasının
sanallaştırdığı konumları çözümlemeyi eklemek zorunda kalacaktık ve bu bize hız kaybettirecekti.</p>
<p>O yüzdendir ki sistem dillerinin neredeyse tamamı hem temizlik algoritmalarını,
hem de sanal makinaları ve diğer aracı algoritmaları reddeder. Çünkü bu seviyede bir hız kaybı
işlevsel olarak kabul edilemez. Yazılımlarımızın öngörülebilir olmasını istiyoruz çünkü sistem dilleriyle
genelde sürücüler, sanal makineler, işletim sistemleri, veritabanları vs gibi hayatî
yazılımların en kötü senaryolarındaki hızları üzerinden hayatî hız hesaplamaları yapıyoruz ve
her bir algoritmayı eklediğinizde, bu algoritmanın doğası nasıl olursa olsun, öngörülebilirlikten ödün
veriliyor.</p>
<p>Bu durumda şunu diyebilir miydik ? “Zaten işletim sistemleri ardışık verileri bize istediğimizde veriyor,
hem sanal makinaların faydalarından yararlanır hem de sistem dillerinin hızlı doğasının tadını çıkarırdık.”
Bunu yapmak tabi ki de mümkün ve zaten pek çok dil yapıyor. Yukarıda andığım C# çok iyi tasarlanmış;
yıldırım hızında çalışan dillerden bir tanesi ama mesele o değil. Sistem dillerinin
tasarım amacı bilgisayarla aracısız konuşmak. Yani malı toptancıdan değil fabrikadan alıyormuşsunuz gibi
düşünün.</p>
<p>Daha önemlisi hız kazanmak için olguları ve sorunları olabildiğince doğrusal düşünmek gerekiyor. Yukarıdaki
t32X20’lik dizide ne yaparsan yap o diziyi gezmek için mecburen bir döngü kullanacaksınız ve
O(n) öngörüsünde çalışacaksınız. Yani
veri türünüz algoritmayı belirliyor. 2 boyutlu doğası olan bir tür için zorlasanız zorlasanız
O(nlog(n)) senaryosunda algoritma geliştirebilirsiniz ki bu şu anlama geliyor elinizdeki veriye göre
algoritma O(n^2) gibi de çalışabilir. Özet olarak kullandığınız tür algoritmanızı belirliyor.</p>
</div>
<p>Derleyicide gerçekleşen şey ise çok basit, derecelendirme işlemi konum aritmetiği yapmadan
dereceyi düşürüp tutulu konumdaki veriyi getiriyor; dizi gibi yorumladığı konumlar için ise
konum aritmetiği yapıp derecesini düşürerek veriyi dönüyor.</p>
</section>
<section id="ceviriler">
<h5>Çeviriler:<a class="headerlink" href="#ceviriler" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Boyut ve derece kavramlarının kesiştiği yeri tartıştık ama bir soruyu cevaplamadık.
Dizi erişim işlemi bir konumdan diğerine nasıl ilerliyor ya da geriliyor ?
Basitçe cevap vereyim; genişliğine ve sıralama katsayısına göre.</p>
<dl class="simple">
<dt>::</dt><dd><p>Bu iki kavramı hafıza yönetimi
başlığı altında ayrıntılı bir şekilde tartışacağız ama
burada ‘sıralama’ kavramını hafıza yönetimindeki ilişkilerinden
bağımsızmış gibi düşünmemiz gerekiyor.</p>
</dd>
</dl>
<p>İyi güzel de <strong>‘yeni’</strong> işlemi özünde posix
sistem çağrılarından biri olan <strong>‘malloc’</strong> işlemine
gönderme yapıyor ve o işlem bize <strong>t8</strong> dizisi dönüyor. Nasıl oluyor da
<strong>t8</strong> dizisini bir türmüş ya da diziymiş gibi kullanıyoruz. ?
İşletim sisteminden alınan hafıza bölgesini,
Örs derleyicisine hedef türün genişlik ve sıralama bilgilerine göre yorumlattırarak.
Nesneler derlenirken, Örs onların genişlik ve sıralama bilgilerinin
çok sıkı muhasebesini yapıyor.
Yukarıda <strong>‘yeni(t32[20])’</strong> işlemi çağrısının sade posix malloc çağrısından farkı
bu muhasebeden kaynaklanıyor.</p>
<p>Çeviri işlemi dönülen değere istenilen sıralama ve genişlik bilgilerinin muhasebesini ekliyor
ki taşma, yanlış okuma, boş konum vs gibi ciddi sorunlar
derleme süresince yakalansın ve eğer muhasebe doğru
yapılmıyorsa uyarı verilsin.
Bu yönüyle çeviri işlemi gerçek işlem değildir.
Derleyicinin genişlik ve sıralama muhasebesinin yönlendirilmesidir.
‘BoyutKavramıÖrneği’ işlemini yeniden yazarak gösterelim:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">BoyutKavramıÖrneği2</span>
<span class="p">{</span>
  <span class="n">Sayılar</span> <span class="o">:=</span> <span class="o">&lt;*</span><span class="n">t32</span><span class="o">&gt;</span><span class="n">stdlib</span><span class="p">::</span><span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="o">*</span><span class="nd">@t32</span><span class="p">);</span>
  <span class="n">her</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">stdio</span><span class="p">::</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&#39;ıncı pis değer : </span><span class="si">%d</span><span class="s2">; konumu : %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
      <span class="n">i</span><span class="p">,</span> <span class="n">Sayılar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Sayılar</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">sil</span> <span class="n">Sayılar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Birinci örnekle özlerinde aynı ama çeviri işlemiyle
<strong>‘Sayılar’</strong> değerinin <strong>t32</strong> konumu olduğu belirtiliyor. Diğer taraftan <strong>‘yeni’</strong>
işlemi ise bu görevi gözlerden ırak bir şekilde zaten yapıyor ama gerçekleşen şey, sonuç, çıktı aynı.</p>
<p>Konum çevrilerini sadece kaynak isterken değil,
elimizdeki kaynaklar yorumlarken de kullanabiliriz.
Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">KonumYorumuÖrneği</span>
<span class="p">{</span>
  <span class="o">//</span><span class="n">onaltılık</span> <span class="n">ascii</span> <span class="n">değerleri</span> <span class="n">içeren</span> <span class="n">bir</span> <span class="n">t64</span> <span class="n">sayısı</span> <span class="n">başlatıyoruz</span><span class="o">.</span>
  <span class="o">//</span><span class="n">ilk</span> <span class="n">sekiz</span> <span class="n">baytın</span> <span class="mi">0</span> <span class="n">olduğunun</span> <span class="n">altını</span> <span class="n">çizerim</span><span class="o">.</span>
  <span class="n">değer</span> <span class="n">sayı</span> <span class="n">t64</span> <span class="o">=</span> <span class="mh">0x0_47_46_45_44_43_42_41</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">t64</span> <span class="n">konumunu</span> <span class="n">yeni</span> <span class="n">değere</span> <span class="n">atıyoruz</span><span class="o">.</span>
  <span class="n">SayıKonumu</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">sayı</span><span class="p">;</span>

  <span class="o">//</span><span class="n">t64</span> <span class="n">konumunu</span><span class="p">,</span> <span class="n">t8</span> <span class="n">konumuna</span> <span class="n">çeviriyoruz</span>
  <span class="n">Harfler</span>    <span class="o">:=</span> <span class="o">&lt;*</span><span class="n">t8</span><span class="o">&gt;</span><span class="n">SayıKonumu</span><span class="p">;</span>

  <span class="o">//</span><span class="n">Sonuçları</span> <span class="n">yazdırıyoruz</span><span class="o">.</span>
  <span class="n">stdio</span><span class="p">::</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sayı konumu: %p</span><span class="se">\n</span><span class="s2">Harfler konumu: %p</span><span class="se">\n</span><span class="s2">Harfler içeriği </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">SayıKonumu</span><span class="p">,</span> <span class="n">Harfler</span><span class="p">,</span> <span class="n">Harfler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Burada t64 sayı değerinin konumu harfler dizisiymiş gibi yorumlanıyor.
Derleyici ise 8 bayt genişliğindeki ve 8 bayt sıralamasındaki t64 konumunu,
1 bayt genişliğinde ve sıralamasındaki t8 değerleri tutan Harfler konumuna çeviriyor.
Bu konunun altı belirgin bir şekilde çizilmeli, çevirme işleminin bilgisayar, işlemci,
işletim sistemi için anlamı yok. Derleyiciler için var ki değerlerin konumlarını
üretim sürecinde hesaplayabilsinler.</p>
<p>Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">ÇeviriÖrneği1</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">sayı</span> <span class="n">t64</span> <span class="o">=</span> <span class="mh">0x0_47_46_45_44_43_42_41</span><span class="p">;</span>
  <span class="n">SayıKonumu</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">sayı</span><span class="p">;</span>
  <span class="n">Harfler</span>    <span class="o">:=</span> <span class="o">&lt;*</span><span class="n">t8</span><span class="o">&gt;</span><span class="n">SayıKonumu</span><span class="p">;</span>
  <span class="n">Tamlar</span>     <span class="o">:=</span> <span class="o">&lt;*</span><span class="n">t32</span><span class="o">&gt;</span><span class="n">SayıKonumu</span><span class="p">;</span>
  <span class="n">Simgeler</span>   <span class="o">:=</span> <span class="o">&lt;*</span><span class="n">t16</span><span class="o">&gt;</span><span class="n">SayıKonumu</span><span class="p">;</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
    <span class="s2">&quot;Sayı Konumu: %p</span><span class="se">\n</span><span class="s2">Harfler konumları:</span><span class="se">\n</span><span class="s2"> [0]:%p</span><span class="se">\n</span><span class="s2"> [1]:%p</span><span class="se">\n</span><span class="s2"> [2]:%p</span><span class="se">\n</span><span class="s2"> [3]:%p</span><span class="se">\n</span><span class="s2"> [4]:%p</span><span class="se">\n</span><span class="s2"> [5]:%p</span><span class="se">\n</span><span class="s2"> [6]:%p</span><span class="se">\n</span><span class="s2"> [7]:%p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">SayıKonumu</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Harfler</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
    <span class="s2">&quot;Sayı konumu: %p</span><span class="se">\n</span><span class="s2">Simgeler Konumları:</span><span class="se">\n</span><span class="s2">[0]:%p</span><span class="se">\n</span><span class="s2">[1]:%p</span><span class="se">\n</span><span class="s2">[2]:%p</span><span class="se">\n</span><span class="s2">[3]:%p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">SayıKonumu</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Simgeler</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Simgeler</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="n">Simgeler</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Simgeler</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
    <span class="s2">&quot;Sayı konumu: %p</span><span class="se">\n</span><span class="s2">Tamlar Konumları:</span><span class="se">\n</span><span class="s2">[0]:%p</span><span class="se">\n</span><span class="s2">[1]:%p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">SayıKonumu</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Tamlar</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Tamlar</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="o">/*</span>
  <span class="n">Benim</span> <span class="n">bilgisayarımda</span> <span class="n">böylesi</span> <span class="n">bir</span> <span class="n">çıktı</span> <span class="n">veriyor</span><span class="p">:</span>
  <span class="n">Sayı</span> <span class="n">Konumu</span><span class="p">:</span> <span class="mh">0x7ffcc51683d0</span>
  <span class="n">Harfler</span> <span class="n">konumları</span><span class="p">:</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mh">0x7ffcc51683d0</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mh">0x7ffcc51683d1</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mh">0x7ffcc51683d2</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="mh">0x7ffcc51683d3</span>
  <span class="p">[</span><span class="mi">4</span><span class="p">]:</span><span class="mh">0x7ffcc51683d4</span>
  <span class="p">[</span><span class="mi">5</span><span class="p">]:</span><span class="mh">0x7ffcc51683d5</span>
  <span class="p">[</span><span class="mi">6</span><span class="p">]:</span><span class="mh">0x7ffcc51683d6</span>
  <span class="p">[</span><span class="mi">7</span><span class="p">]:</span><span class="mh">0x7ffcc51683d7</span>
  <span class="n">Sayı</span> <span class="n">konumu</span><span class="p">:</span> <span class="mh">0x7ffcc51683d0</span>
  <span class="n">Simgeler</span> <span class="n">Konumları</span><span class="p">:</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mh">0x7ffcc51683d0</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mh">0x7ffcc51683d2</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mh">0x7ffcc51683d4</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="mh">0x7ffcc51683d6</span>
  <span class="n">Sayı</span> <span class="n">konumu</span><span class="p">:</span> <span class="mh">0x7ffcc51683d0</span>
  <span class="n">Tamlar</span> <span class="n">Konumları</span><span class="p">:</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mh">0x7ffcc51683d0</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mh">0x7ffcc51683d4</span>
<span class="o">*/</span>
</pre></div>
</div>
<p>İşlemin çıktısından farkedeceğiniz üzere,
<strong>‘Harfler’</strong> dizisindeki konumlar teker teker,
<strong>‘Simgeler’</strong> disisindeki konumlar çifter çifter,
<strong>‘Tamlar’</strong> dizisindeki konumlar ise dörder dörder artmış.
Derleyici üretim aşamasında genişlik ve sıralama muhasebesini
tutuyor ki, dizi erişim ve diğer konum işlemleri canlı çalışırken
görevlerini verilerin ardışıklığını ve sıralamasını bozmadan icra edebilsinler.</p>
<div class="admonition note">
<p class="admonition-title">Not</p>
<p>Bu örnekte bayt genişliği ve sıralamanın, dizi erişiminin ibresiyle birebir hareket
etmesi, kullanılan türlerin yapıtaşı olmasından kaynaklanıyor. Türler için
bayt genişliği ve sıralama illa ki aynı olacak diye bir kaide yok.</p>
</div>
</section>
<hr class="docutils" />
<section id="sey">
<h5>Şey:<a class="headerlink" href="#sey" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p><strong>‘şey’</strong> yapıtaşı; <strong>‘mimari’</strong> genişliğinde olan ve içinde herhangi dereceden herhangi
konumu tutan veya tutmayan yapıtaşıdır.</p>
<p>Tıpkı nasıl ardışık türlerin ayağını yere bastırmak için dizi türünü tanımladıysak,
konum kavramının da ayağını bir yapıtaşı ile yere değdirmemiz gerekiyor.</p>
<p>C dilindeki dengi <strong>‘void*’</strong> türüdür ama Örs dilinde</p>
</section>
<section id="sonuc">
<h5>Sonuç:<a class="headerlink" href="#sonuc" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Konumlar konusunda ne kadar çok kavram kümesiyle iletişimde bulunduğumuzu gördünüz.
Yeni başlayanlar için göze korkutucu gelebiliyor ama ustalar için konumlara ayar çekebilme
yeteneği büyük bir güç ve Örs bu konuda üzerinde iyi düşünülmüş araçlara sahip.</p>
</section>
</section>
<span id="document-bolumler/tanıtım/ifadeler/metin"></span><section id="metinler">
<h4>Metinler<a class="headerlink" href="#metinler" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<section id="harf">
<h5>Harf<a class="headerlink" href="#harf" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Hepimizin bildiği 8 bit genişliğinde ascii simgeleridir.
Unicode ve daha geniş verileri kabul etmezler.
Varsayılan türleri harf yani ‘t8’ türüdür.</p>
<p>Tıpkı diğer C ailesi üyeleri gibi ‘a’ şeklinde ifade edilirler. Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">a</span> <span class="n">harf</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
<span class="n">b</span>           <span class="o">:=</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
<span class="n">c</span>           <span class="o">:=</span> <span class="mh">0x63</span><span class="n">_st8</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="harfler">
<h5>Harfler<a class="headerlink" href="#harfler" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Boyutu durağan belirlenmiş harf dizileridir.
Utf8 ve Unicode kabul ederler.
Sıralandıklarında tek bir dizi gibi kabul edilirler.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">ö</span> <span class="o">*</span><span class="n">t8</span> <span class="o">=</span> <span class="s2">&quot;örs dili&quot;</span><span class="p">;</span>
<span class="n">sıralı</span> <span class="o">:=</span> <span class="s2">&quot;Sıralandıklarında&quot;</span>
  <span class="s2">&quot;tek bir dizi gibi&quot;</span>
  <span class="s2">&quot;kabul edilirler&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Örs’de harfler türü mimari türünün bayt boyutunun katlarıdır ve sıralıdır.</p>
</section>
</section>
<span id="document-bolumler/tanıtım/ifadeler/temel_işlemler"></span><section id="temel-islemler">
<h4>Temel İşlemler<a class="headerlink" href="#temel-islemler" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Yazılım dünyasında işlevi yönünden özüne indirgenmiş, görevi önceden tasarlanmış
ifadelere denir.</p>
<p>Bu indirgemedeki hedef temel işlemin en az makina dili ile
işlemci için ifade edilmesi,
eğer indirgenemiyorsa mümkün olduğunca durağanlaştırılması;
yani derleme sürecinde o işlemlerin sonuçlandırılmasıdır. Özüne
indirgenmiş deyimiyle kastedilen budur.</p>
<p>Bazı ifadeler ise yazılımlarda tekrar eder. Mesela çok fazla geçirme
işlemi yapan algoritmalarda bu geçirme işlemi görevleri önceden
tasarlandığı haliyle temel işlem olarak kullanılabilir. Görevi
önceden tasarlanmış deyimiyle ise kastedilen budur.</p>
<p>Canlı temel işlemler; işlemci tarafından çalıştırılabilirken;
durağan temel işlemler üretim sürecinde sonuçlandırılır. İlki işlemciyi
hedef alırken; durağan temel işlemler derleyici hedef alır.</p>
<p>Canlı temel işlemlerin
makina dilinde birebir karşılığı bazen olabilir. Matematik, Mantık,
Konum, Erişim sınıfındaki işlemlerin genelde işlemci komutu karşılığı vardır.
Diğer sınıfta canlı işlemler malesef aynı görevi üstlenmiş işlemci komutu almayabilir.
Mesela <strong>‘+=’</strong> önce değer ile yapıtaşını toplayacak sonra ise sağdaki değere geçirecek.
Bu temel işlemin işlemci komutlarında karşılığı olsaydı zaten yazılım dillerine gerek olmazdı.</p>
<div class="admonition warning">
<p class="admonition-title">Uyarı</p>
<p>Tekrar belirtelim; yapısal dillerdeki temel işlemlerin
hepimizin bildiği matematikteki temel işlemlerle alakası bile yoktur.</p>
<p>Hatta matematikten ödünç alınmış işlemlerin bile bize lise ve
üniversitede öğretilen işlemlerle alakası yoktur. Bize
sürekli matematik öğretilmiş iken
bilgisayar dünyasındaki matematik işlemleri sıralı
matematiğin alanına (ingilizcesi:discrete mathematics) girer.</p>
</div>
<p>Örs dili C ailesinin temel işlemlerini değiştirmemesine
rağmen kendi içinde yeni temel işlemler de ekler.</p>
<p>C++ dilinin aksine Örs temel işlemleri yeniden tanımlatmaya izin vermez.
Nedeni ise yazılım dünyasında bu konuda bir anlaşmanın olmaması
ve herkesin fevri simgelerle bir takım işlemleri kolaylaştırma
çabasının kodu okunamaz hale getirmesidir.</p>
<p>C dil ailesinde tüm temel işlemler sola doğru döndüğü için Örs’de bu kaideye uyar.</p>
<p>Temel işlemler çeşitli özelliklerine göre sınıflandırılabilir.
Aşağıda söz dizimine göre sınıflandırarak bu işlemleri tanıtacağız.</p>
<section id="ikiz-islemler">
<h5>İkiz işlemler:<a class="headerlink" href="#ikiz-islemler" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p><strong>‘(ifade) işlem (ifade)’</strong>
söz dizisiyle sağ ve sol ifadeler bekleyen işlemlerdir:</p>
<p><strong>Aritmetik:</strong></p>
<ul class="simple">
<li><p><strong>‘+’</strong>, <strong>‘-’</strong> simgeleri sağ ve sollarındaki sayısal ifadeleri sırasıyla toplar ve çıkarır.</p></li>
<li><p><strong>‘*’</strong>, <strong>‘/’</strong> simgeleri sağ ve sollarındaki sayısal ifadeleri sırasıyla çarpar ve böler.</p></li>
<li><p><strong>‘%’</strong> simgesi solundaki sayı türündeki değer sağındaki sayı türündeki değere bölününce kalan değerini verir.</p></li>
</ul>
<p><strong>Bit:</strong></p>
<ul class="simple">
<li><p><strong>‘&amp;’</strong></p></li>
<li><p><strong>‘|’</strong></p></li>
<li><p><strong>‘^’</strong></p></li>
<li><p><strong>‘~’</strong></p></li>
<li><p><strong>‘&lt;&lt;’</strong></p></li>
<li><p><strong>‘&gt;&gt;’</strong></p></li>
</ul>
<p><strong>Mantıksal:</strong></p>
<ul class="simple">
<li><p><strong>‘&amp;&amp;’</strong>, <strong>‘ve’</strong> simgeleri sağ ve sollarındaki sayısal değerleri mantıktaki ‘ve’ işlemi ile karşılaştırır.</p></li>
<li><p><strong>‘||’</strong>, <strong>‘veya’</strong> simgeleri sağ ve sollarındaki sayısal değerleri mantıktaki ‘veya’ işlemi ile karşılaştırır.</p></li>
</ul>
<p><strong>Karşılaştırma:</strong></p>
<ul class="simple">
<li><p><strong>‘&lt;’</strong>: sayı türündeki değerleri niceliklerine göre karşılaştırır ve sağı küçükse 1 döner.</p></li>
<li><p><strong>‘&gt;’</strong>: sayı türündeki değerleri niceliklerine göre karşılaştırır ve sağı büyükse 1 döner.</p></li>
<li><p><strong>‘&lt;=’</strong>: sayı türündeki değerleri niceliklerine göre karşılaştırır ve sağı küçükse 1 döner.</p></li>
<li><p><strong>‘&gt;=’</strong>: sayı türündeki değerleri niceliklerine göre karşılaştırır ve sağı büyükse 1 döner.</p></li>
<li><p><strong>‘==’</strong>: sayı türündeki değerler eşit ise 1 döner.</p></li>
<li><p><strong>“!=”</strong>: sayı türündeki değerler eşit değil ise 1 döner.</p></li>
</ul>
<p><strong>Atama:</strong></p>
<ul class="simple">
<li><p><strong>‘+=’</strong>:  sağındaki değeri solundakiyle toplar ve soldaki değere geçirir.</p></li>
<li><p><strong>‘-=’</strong>:  sağındaki değeri solundakiyle çıkarır ve soldaki değere geçirir.</p></li>
<li><p><strong>‘*=’</strong>:  sağındaki değeri solundakiyle çarpar ve soldaki değere geçirir.</p></li>
<li><p><strong>‘/=’</strong>: sağındaki değeri solundakiyle böler ve soldaki değere geçirir.</p></li>
<li><p><strong>‘%=’</strong>:  sağındaki değeri solundakiyle kalma işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘&lt;&lt;=’</strong>: sağındaki değeri solundakiyle sola kaydırma işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘&gt;&gt;=’</strong>: sağındaki değeri solundakiyle sağa kaydırma işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘||=’</strong>: sağındaki değeri solundakiyle ‘veya’ işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘&amp;&amp;=’</strong>: sağındaki değeri solundakiyle ‘ve’ işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘~=’</strong>:  sağındaki değeri solundakiyle ‘bit tersleme’ işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘&amp;=’</strong>:  sağındaki değeri solundakiyle ‘bit ve’ işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘|=’</strong>:  sağındaki değeri solundakiyle ‘bit veya’ işlemini uygular ve soldaki değere geçirir.</p></li>
<li><p><strong>‘^=’</strong>:  sağındaki değeri solundakiyle ‘ters bit veya’ işlemini uygular ve soldaki değere geçirir.</p></li>
</ul>
<p><strong>Hafıza:</strong></p>
<ul class="simple">
<li><p><strong>‘&lt;-’</strong>: Sağındaki konumun değerini dönüp; solundaki değere geçirir.</p></li>
<li><p><strong>‘&lt;=&gt;’</strong>: Sağ ve soldaki konumların değerlerini değiştirir.</p></li>
</ul>
<p><strong>Arama:</strong></p>
<ul class="simple">
<li><p><strong>‘::’</strong>: Birimde tanımlı nesneleri arar ve bulursa döner.
Bulamazsa hata verip derlemeyi sonlandırır.</p></li>
</ul>
<p><strong>Erişim:</strong></p>
<ul class="simple">
<li><p><strong>‘-&gt;’</strong>: Soldaki türün konumuna erişir ve sağındaki aranan ifadeyi tür üyesi olarak bulabilirse döner.</p></li>
<li><p><strong>‘.’</strong>:  Soldaki türün değerine erişir ve sağındaki aranan ifadeyi tür üyesi olarak bulabilirse döner</p></li>
</ul>
</section>
<section id="tekil-islemler">
<h5>Tekil İşlemler:<a class="headerlink" href="#tekil-islemler" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p><strong>Adım:</strong></p>
<ul class="simple">
<li><p><strong>‘(ifade)++’</strong>: solundaki sayısal ya da konum ifadesinin değerini,
ifadeyi değerlendirdikten sonra, bir birim arttırır.</p></li>
<li><p><strong>‘++(saf ifade)’</strong>: sağındaki sayısal ya da konum saf ifadesinin değerini, ifadeyi
değerlendirmeden önce, bir birim arttırır.</p></li>
<li><p><strong>‘(ifade)--’</strong>: solundaki sayısal ya da konum ifadesinin değerini,
ifadeyi değerlendirdikten sonra, bir birim azaltır.</p></li>
<li><p><strong>‘--(saf ifade)’</strong>: sağındaki sayısal ya da konum saf ifadesinin değerini, ifadeyi
değerlendirmeden önce, bir birim azaltır.</p></li>
</ul>
<p><strong>Konum:</strong></p>
<ul class="simple">
<li><p><strong>‘*(konum ifadesi)’</strong>: Solunda verili konumun değerini döner.</p></li>
<li><p><strong>‘&amp;(değer ifadesi)’</strong>:  Solunda verili değerin konumunu döner.</p></li>
<li><p><strong>‘(konum ifadesi)[x]</strong>: Solunda verili konumun x’inci sıradaki değerini döner.</p></li>
</ul>
<p><strong>Tür nicelik:</strong></p>
<ul class="simple">
<li><p><strong>‘&#64;(ifade)’</strong>: Solunda verili ifadenin bayt boyutunu döner.</p></li>
<li><p><strong>‘$(ifade)’</strong>: Solundaki verili ifadenin bayt sıralamasını döner.</p></li>
</ul>
<p><strong>Tür:</strong></p>
<ul class="simple">
<li><p><strong>‘%(ifade)’</strong>: Sağındaki ifadenin türünü döner. Üretim sürecinde anlamlı olsa da Örs durağan bir dil olduğu için;
canlı anlamı yoktur.</p></li>
</ul>
<dl>
<dt>Tanımlı yapıtaşları:</dt><dd><table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 10%" />
<col style="width: 4%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Temel İşlemler</strong></p></th>
<th class="head"><p>İsim</p></th>
<th class="head"><p>Tür</p></th>
<th class="head"><p>Makina Satırı Sayısı</p></th>
<th class="head"><p>Görev</p></th>
<th class="head"><p>İşleme durumu</p></th>
<th class="head"><p>Okuma Yeri</p></th>
<th class="head"><p>Eş Anlamlısı</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Aritmetik</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>+</strong></p></td>
<td><p>artı</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>aritmetik</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>-</strong></p></td>
<td><p>eksi</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>aritmetik</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>*</p></td>
<td><p>çarpı</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>aritmetik</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>/</strong></p></td>
<td><p>bölme</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>aritmetik</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>%</strong></p></td>
<td><p>kalma</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>aritmetik</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>Bit</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>&amp;</strong></p></td>
<td><p>bit ve</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>bit</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>|</strong></p></td>
<td><p>bit veya</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>bit</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>^</strong></p></td>
<td><p>bit ters veya</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>bit</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>~</strong></p></td>
<td><p>bit tersleme</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>bit</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>&lt;&lt;</strong></p></td>
<td><p>sola kaydırma</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>bit</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&gt;&gt;</strong></p></td>
<td><p>sağa kaydırma</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>bit</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>Mantık</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&amp;&amp;</strong></p></td>
<td><p>ve</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt; 1</p></td>
<td><p>mantık</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td><p>ve</p></td>
</tr>
<tr class="row-odd"><td><p><strong>||</strong></p></td>
<td><p>veya</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt; 1</p></td>
<td><p>mantık</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td><p>veya, ya_da</p></td>
</tr>
<tr class="row-even"><td><p><strong>!</strong></p></td>
<td><p>değil</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>mantık</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>Karşılaştırma</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&lt;</strong></p></td>
<td><p>küçüktür</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>karşılaştırma</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>&gt;</strong></p></td>
<td><p>büyüktür</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>karşılaştırma</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&lt;=</strong></p></td>
<td><p>küçük eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>karşılaştırma</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>&gt;=</strong></p></td>
<td><p>büyük eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>karşılaştırma</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>==</strong></p></td>
<td><p>eşitlik</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>karşılaştırma</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>!=</strong></p></td>
<td><p>eşit değildir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>1</p></td>
<td><p>karşılaştırma</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>Adım</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>(..)++</strong></p></td>
<td><p>arka artış</p></td>
<td><p>yapıtaşı, konum</p></td>
<td><p>satır &gt; 1</p></td>
<td><p>adım</p></td>
<td><p>canlı</p></td>
<td><p>son</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>++(..)</strong></p></td>
<td><p>ön artış</p></td>
<td><p>yapıtaşı, konum</p></td>
<td><p>satır &gt; 1</p></td>
<td><p>adım</p></td>
<td><p>canlı</p></td>
<td><p>ön</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>(..)--</strong></p></td>
<td><p>arka azalış</p></td>
<td><p>yapıtaşı, konum</p></td>
<td><p>satır &gt; 1</p></td>
<td><p>adım</p></td>
<td><p>canlı</p></td>
<td><p>son</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>--(..)</strong></p></td>
<td><p>ön azalış</p></td>
<td><p>yapıtaşı, konum</p></td>
<td><p>satır &gt; 1</p></td>
<td><p>adım</p></td>
<td><p>canlı</p></td>
<td><p>ön</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>Konum</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>*</p></td>
<td><p>derecelendirme</p></td>
<td><p>konum</p></td>
<td><p>1</p></td>
<td><p>konum</p></td>
<td><p>canlı</p></td>
<td><p>ön</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>&amp;</strong></p></td>
<td><p>konumlandırma</p></td>
<td><p>konum</p></td>
<td><p>1</p></td>
<td><p>konum</p></td>
<td><p>canlı</p></td>
<td><p>ön</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>[]</strong></p></td>
<td><p>dizi erişim</p></td>
<td><p>konum</p></td>
<td><p>1</p></td>
<td><p>dizi, konum</p></td>
<td><p>canlı</p></td>
<td><p>son</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>Nicelik</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&#64;</strong></p></td>
<td><p>boyut</p></td>
<td><p>tüm türler</p></td>
<td><p>0</p></td>
<td><p>nicelik</p></td>
<td><p>durağan</p></td>
<td><p>ön</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>$</strong></p></td>
<td><p>sıralama</p></td>
<td><p>tüm türler</p></td>
<td><p>0</p></td>
<td><p>nicelik</p></td>
<td><p>durağan</p></td>
<td><p>ön</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>Atama</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>=</strong></p></td>
<td><p>eşittir</p></td>
<td><p>tüm türler</p></td>
<td><p>satır &gt; 1</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>+=</strong></p></td>
<td><p>artı eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>-=</strong></p></td>
<td><p>eksi eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>*=</strong></p></td>
<td><p>çarp eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>/=</strong></p></td>
<td><p>böl eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>%=</strong></p></td>
<td><p>kal eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>&lt;&lt;=</strong></p></td>
<td><p>sola kay eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&gt;&gt;=</strong></p></td>
<td><p>sağa kay eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>||=</strong></p></td>
<td><p>veyala eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&amp;&amp;=</strong></p></td>
<td><p>vele eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>~=</strong></p></td>
<td><p>bit tersle eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&amp;=</strong></p></td>
<td><p>bit vele eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>|=</strong></p></td>
<td><p>bit yadala eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>^=</strong></p></td>
<td><p>bit ters yadala eşittir</p></td>
<td><p>yapıtaşı</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>atama</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>Tür Erişim</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>-&gt;</strong></p></td>
<td><p>tür alt konuma erişim</p></td>
<td><p>türler</p></td>
<td><p>2</p></td>
<td><p>tür erişim</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>.</strong></p></td>
<td><p>türü indirgeme</p></td>
<td><p>türler</p></td>
<td><p>1</p></td>
<td><p>tür erişim</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>Hafıza</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>&lt;-</strong></p></td>
<td><p>geçirme</p></td>
<td><p>~</p></td>
<td><p>satır &gt;= 2</p></td>
<td><p>hafıza</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>&lt;=&gt;</strong></p></td>
<td><p>içerik değiştirme</p></td>
<td><p>~</p></td>
<td></td>
<td><p>hafıza</p></td>
<td><p>canlı</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>Arama</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>::</strong></p></td>
<td><p>arama</p></td>
<td><p>birimler</p></td>
<td><p>0</p></td>
<td><p>arama</p></td>
<td><p>durağan</p></td>
<td><p>orta</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>Tür İfadesi</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>%</strong></p></td>
<td><p>tür alma</p></td>
<td><p>tüm türler</p></td>
<td><p>0</p></td>
<td><p>tür ifadesi</p></td>
<td><p>durağan</p></td>
<td><p>ön</p></td>
<td></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</section>
</section>
</div>
</section>
<span id="document-bolumler/tanıtım/satırlar"></span><section id="satirlar">
<h3>Satırlar<a class="headerlink" href="#satirlar" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<div class="toctree-wrapper compound">
<span id="document-bolumler/tanıtım/satırlar/giris"></span><section id="satirlar">
<h4>Satırlar:<a class="headerlink" href="#satirlar" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Yazılım dünyasında meşur bir tartışma konusu var.
Gerçekten kılavuzun tamamında bu tartışmaya atıflar var ve değinmemiz gerektiğini düşünüyorum.</p>
<p>Kod kalitesini ya da miktarını <strong>0x0A</strong> ascii numarası ile anlamlandırılan yeni satır
imgesi ile ölçebilir miyiz ölçemez miyiz ?</p>
<p>Böyle bir şeyin neden tartışılması gerektiği bir yana; gülünç bir
şekilde alakalı isteği iş başvurusunda gördüm.
İşveren ilanında “en az on bin satır kod yazmış olan.” diye şart koşmuş.</p>
<p>Burada kastedilen şey ne olabilir ki ? Eğer kastedilen şey
&quot;üretiğiniz yazılımlarınızda ne kadar <strong>‘0x0A’</strong>
kodu var ?&quot; ise zaten öyle saçma yazılım şirketinde çalışılmaz, o işverenle iş yapılmaz.
Mesela jquery.min.js kütüphanesi tek metin satırlı. Örs ve benzeri dillerde hiç satırla
yazılım üretmeniz fevkâlade mümkün ve anlamlı.</p>
<p>Diğer taraftan kastedilen <strong>şey</strong> eğer ki eğer bizim yazılım okurken algıladığımız <strong>şey</strong> ise
gerçekten anlamlı ve derin doğaya sahip bir <strong>şey</strong> ile karşı karşıyayız ve bu <strong>şey</strong>'in ne
olduğu hem Örs derleyicisi için hem de bu kılavuz için çok önemli.</p>
<p>Basitçe örnek vermem gerekirse: Ayak deyince aklınıza gelen ilk <strong>şey</strong> kendi ayağınız mı,
masanızın ayağı mı, yoksa sandalyenin ayağı mı ? Tamam, dediniz ki &quot;Kendi ayağım&quot;.
Kaç tane ayağınız var ? İki. Peki ayak tanımını
&quot;Sizin ayakta durmanızı sağlayan uzuv.&quot; olarak tanımlayıp
tekrar &quot;Kaç ayağınız var ?&quot; diye sorsam ?
Elleriniz üzerinde, kafanız üzerinde de ayakta durmanız mümkün. Elleriyle ayakta durarak
yürüyen engelli insanlar, kafalarının üzerinde ayakta durup raks eden dansçılar var.</p>
<p>&quot;Ya ne alakası var yazılımla bunun yine delirdi Musa !&quot;, değil mi ?
Deliliğe daha geliyoruz biraz sabredin.
Size daha “işlemci kaç satır görüyor peki ?” diye sorup dumur edeceğim.</p>
<p>Diyelim ki ayak deyince aklınıza masanızın ayağı geldi. Yine yukarıdaki diyalektiği
takip edelim. “Masanızın kaç ayağı var ?” diye sorsam ve ben yukarıdaki ayak tanımına uyarak cevap versem.
Mesela benim masam kutu tasarımına sahip ve bacak gibi kesilmiş kerestelerle değil
levhalarla ayakta duruyor ve 3 farklı levha parçası var ama tasarım kutu tasarımı olduğu için
kutunun yan yüzü olarak görürsem 1 parça var.</p>
<p>Tekrar ayak uzvumuza geri dönelim. “Sizin ayakta durmanızı sağlayan uzva ayak denir.” tanımı ile
topuklarımın üzerinde ayakta durduğum için topuklarımı da ayak sayabilir miyim ?
Peki balerinler parmakları üzerinde ayakta duruyor o zaman
Evet ve bunu ısrarla uzatıp iletişim kuramını kullanarak matematikle de kanıtlarım.</p>
<p>Şimdi bizim satır deyince yazılımda algıladığımız <strong>şey</strong> ne ?
Bizim gördüğümüz mü ? Yani <strong>0X0A</strong> kodu mu ? Yoksa algıladığımız mı ?
Yoksa Örs derleyicisinin gördüğü mü ?
Yoksa derleyicinin algıladığı mı ? İşlemcinin çalıştırdığı mı ?
Bizim Kasabın et doğradığı mı ? Yoksa hepsi mi ?</p>
<p>Artık internek kanallarından, gazetelere kod satırları haber olunca; yazılım dünyasında kullanılan
satır kelimesinin hangi <strong>şey</strong>'e atıfta bulunduğunu belirlememiz ve terim haline getirmemiz gerekiyor.</p>
<p>Önerdiğim tanım:
“Yazılım dilleri dünyasında satırlar sıralı ifadelerin anlamlandırılmış kümesidir.”</p>
<p>Örs ve diğer yazılım dilleri de satırları <strong>sıralı ifadelerin kümesi</strong> olarak algılar. Örnek verelim:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">her</span> <span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
   <span class="n">her</span> <span class="n">değer</span> <span class="n">j</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</pre></div>
</div>
<p>Şimdi yapılan satır tanımıyla birlikte yine yukarıdaki diyalektiği yapmaya çalışalım.
Yukarıdaki kod kesitinde kaç satır var ?</p>
<p>Gördüğümüz 3 satır var ama algıladığımız satırları saymaya başlayalım.</p>
<p>Her döngüsü var, sonra bedeni var,
o bedende bir döngü daha var ve onun da bedeni var yani dört diyebilir miyiz ?
Tutarlı olur mu ? En nihayetinde tutarlı olması lazım ki hem derleyici anlayabilsin
hem de bilgisayar çalıştırabilsin.</p>
<p>Peki derleyici kaç satır görüyor ? Bu örnek için (3 + 1) + (3 + 1)  satır.
Peki ya işlemci kaç satır çalıştıracak ? Yukarıdaki örnek için (3 + 1) X (3 + 1).
Yani nam-ı diğer hepimizin bildiği O(n^2).
Özünde veri ağaçları olan satırların elamanları derleyici tarafından artarak algılanıyor
diğer taraftan işlemci ise katlayarak algılıyor. Bu konuda yanlışım varsa düzeltilmek isterim.
Zira ya benim liseyi tekrar okumam gerekiyor ya da biri birisinin alt türevi.</p>
<p>Şimdi malum soruya geldik. İşlemci kaç satır görüyor ?</p>
<p>Yukarıdaki tanıma göre görmüyor bile. İşlemcinin baktığı yerden hepsi aslında mimari biti
genişliğinde dizi.
Tıpkı Turingin tanımladığı gibi.
İşletim sistemi yazdığınızı doğrusal olarak hafızaya geçirecek ve
işlemciyi sizin kodunuzu koyduğu konuma yönlendirecek.
Hatta yukarıdaki örnek, Örs, C, C++ vb dillerin iyileştiricileri
tarafından da satır olarak görülmeyecek. Çünkü yukarıdaki döngünün hiçbir görevi yok.
O yüzden işlemcinin calıştıracağı satır derken aslında örtülü bir varsayımda bulunup, derleyicinin iyileştirme
seçeneklerinin kapalı oldunu düşünürek söylüyoruz.</p>
<p>Tam da buralarda satır tanımlamasının rengi bozulmaya başlıyor.
Kendine verilen alanın dışına çıkıyor.
İşte tam bu noktada satır tanımı görevini tamamlamış oluyor. Bu kılavuzda satır kelimesini duyunca aklınıza sadece yukarıdaki tanım gelsin.
Bir matematikçinin, işlemci tasarımcısının, hatta ve hatta güvenlik ve iyileştirme kaygısı güden
yazılımcının kaç satır algılayacağını bilmenin pek bir imkanı yok. Mesela önceki paragrafta iyileştirme aşaması için
yukarıdaki örneğe döngü dedim.
Kümelenmiş iki döngü demedim; &quot;… döngünün hiçbir … &quot; dedim.
Çünkü iyileştirmenin özünde yan etkileri en aza indirmek var ve
gereksiz koddan ziyade yan etki olabilir mi ?
Mâna bu olunca burada tek satırlık bir döngü var orada ama iyileştirici algoritması iç döngünün içerisindeki etkisiz atamayı tespit edene kadar satır sayacak.</p>
<p>Bakınız konu o kadar derinleşmeye başladı ki altında ezilmeye başladım. Fark ettiyseniz mâna kelimesini kullandım.
Anlam kelimesini kullansaydım aklınıza &quot;Bizim anladığımız mı? Derleyicinin anladığı mı ?&quot; diye sorular gelecekti.
Örsün tasarım amaçlarından en güzeli belki de işte bu. Nihayet rüyâ görürken, sinirlenince konuştuğumuz dille bu harika konuları tartışabileceğiz.</p>
</section>
<span id="document-bolumler/tanıtım/satırlar/dongu_satırları"></span><section id="dongu-satirlari">
<h4>Döngü Satırları<a class="headerlink" href="#dongu-satirlari" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Bilgisayar belleğinin aslında devasa bir dizi olduğu düşünülünce, bu dizinin ‘a’
noktasından ‘b’ noktasına gitmeyi istemek kadar temel bir istek olamaz. Tam olarak
bu amacı yerine getirmek için Örs dili çeşitli döngü yöntemleri kullanmaktadır.</p>
<p>Döngülerin amacı verili kod dizisini koşul sağlanmayana kadar tekrar tekrar
işletmektir. Bu yönüyle motorlara benzerler. En basitinden siz arabayı çalıştırdınız ve
arabanın motoru dönmeye başlar ve öyle devam eder ta ki siz motoru kapayıncaya kadar ya da
yakıt bitinceye kadar. Yani siz koşulu sağlamayana kadar o motor çalışmaya devam eder.</p>
<p>Burada dikkat edilmesi gereken husus Örs dilinin C dilinden daha fazla yönlendirmeler
tanımlaması ve döngüler üzerinde daha fazla denetim sağlamasıdır. Yönlendirmeler konusuna
ayrı bir başlık açacağız.</p>
<dl class="glossary">
<dt id="term-Her-Dongusu">Her Döngüsü:<a class="headerlink" href="#term-Her-Dongusu" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">ArgumanlarÖrneği</span>
   <span class="n">argumanSayisi</span>   <span class="n">tam</span><span class="p">,</span>
   <span class="n">_argumanlar</span>   <span class="o">**</span><span class="n">t8</span><span class="p">:</span> <span class="n">tam</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">ilk</span> <span class="n">döngü</span>
   <span class="o">//</span><span class="n">argümanları</span> <span class="n">dizi</span> <span class="n">erişimiyle</span> <span class="n">yazdır</span><span class="o">.</span>
   <span class="n">her</span> <span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argumanSayisi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;-&gt; </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_argumanlar</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

   <span class="o">//</span><span class="n">ikinci</span> <span class="n">döngü</span><span class="p">:</span>
   <span class="o">//</span><span class="n">argümanları</span> <span class="n">konumlarından</span> <span class="n">yazdır</span><span class="o">.</span>
   <span class="n">her</span> <span class="n">değer</span> <span class="n">t</span> <span class="o">**</span><span class="n">t8</span> <span class="o">=</span> <span class="n">_argumanlar</span><span class="p">;</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;=&gt; </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıdaki örneğin ilk 4 satırını göz ardı edecek olursak, bu işlem basitçe,
önce yazılım argümanlarını dizi erişimi ile daha sonra konum erişimiyle yazdırıyor.</p>
<p>‘Her’ sözcüğü ile başlayan satır içerisindeki ilk satırda değer ya da değerler tanımlanır.
Sonrasındaki satırda koşul belirtilir, üçüncü satırda ise tanımlı değerler güncellenir ve her
döngüsünün beden satırına geçilir.</p>
<p>Bu kısmı tabî ki de sadece bir söz dizimi. Hepimizin C dilinden eline yapışmış alışkanlık.
Bu satırların anlam sıralaması farklı olsaydı yani ilkin güncelleyip, sonra koşulu değerlendiremezmiydik ?
Tabi ki de değerlendirebiliriz ama mesele o değil. Örs dili makina diline dönüştüğünde, biz tasarımcılar olarak
istiyoruz ki derleyicinin ürettiği kod C derleyicisinin ürettiği kod ile bire bir eşdeğer olsun.
Yani her döngüsünü yukarıdaki gibi tanımladığınızda, üretilen makina kodu ile C derleyicisinin ürettiği
makina kodu tıpa tıp aynı.</p>
<p>Diğer taraftan tam burada basit bir okuma sorunu ortaya çıkıyor. Özellikle internet, oyun,
arayüz uygulamalarında çoğu zaman döngüyü koşullarla değil sayaçlarla yönlendiriyoruz ve 4 satırlık her döngüsü
okurken göze batıyor. Bir diğer konu ise yukarıdaki söz dizimi makina dili üretirken de 5 satır kod üretiyor.</p>
<blockquote>
<div><p>C tarzı  döngü:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">her</span> <span class="p">;</span> <span class="p">;</span> <span class="n">güncellemeYapacakİşlem</span><span class="p">():</span>
<span class="p">{</span>
   <span class="n">işletilecekBeden</span><span class="p">();</span>
<span class="p">}</span>
<span class="o">/*</span>
   <span class="n">Burası</span> <span class="n">ise</span> <span class="n">devam</span> <span class="n">satırı</span><span class="o">.</span>
<span class="o">*/</span>
</pre></div>
</div>
</div></blockquote>
<p>Şimdi bu döngü satırına basitçe bir ameliyat yapalım. Değer tanımlanması gereken kısımda değer tanımlanmamış. Yani boş satır var.
Koşul satırı yine boş. Güncelleme satırında bir işlem çağırılmış ve bu üretilecek ilk makina dili satırı.
Beden kısmında da dolu satır var ve bu da bizim ikinci makina dili satırımız.</p>
<p>Ama, fakat, lakin o yorumun olduğu yerde bir diğer satır daha var. Devam satırı.
Makina kodunda devam ederken nereye devam edeceğini söylemen gerekiyor. Örs, C, C++ dillerinde devam satırını
siz tabi ki de yazmıyorsunuz ama makina dilinde o satır var ve yukarıdaki döngünün makina dilinde, yani özünde,
3 satırı var.</p>
<p>Peki ama biz işlemci değiliz ki bize ne bundan ? Çok doğru ama biz bu kodu okuyacak olanız.
5 satır tanımlayıp, 3 satır ürettirmenin anlamı yok. Yani argümanlar örneğindeki gibi 4
satırlık döngü tanımladığınızda aslında makina 5 satır kod görecek.
Bu örnekte ise tanım ve koşul kısmı boş satır ve derleyici hiçbir makina kodu üretmeyecek.</p>
<p>Peki öyleyse fazladan iki satırı tanımlamanın ne anlamı var ? Burada basit bir görsel soyutlama yapmamız ve her döngüsünün
söz dizimini kıvraklaştırmamız gerekiyor.</p>
</dd>
<dt id="term-Her-dongusu-soz-dizimi-cesitleri">Her döngüsü söz dizimi çeşitleri:<a class="headerlink" href="#term-Her-dongusu-soz-dizimi-cesitleri" title="Permalink to this term">#</a></dt><dd><dl class="glossary">
<dt id="term-Sonsuz-dongu">Sonsuz döngü:<a class="headerlink" href="#term-Sonsuz-dongu" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">her</span><span class="p">:</span>
   <span class="n">herhangiİşlem</span><span class="p">();</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte görsel uygulamalarda, veri arz uygulamalarında bolca kullanılan bir sonsuz döngü örneği var.
Sadece beden satırında bir takım işlemler çağırılmış.
Derleyici 1 satır görecek ve 2 makina satırı üretecek.</p>
<p>Göze sade görünüyor. Derleyiciye sade görünüyor ve makina zaten sade görecek.</p>
</dd>
<dt id="term-Tanimsiz-dongu">Tanımsız döngü:<a class="headerlink" href="#term-Tanimsiz-dongu" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">her</span> <span class="n">devamMı</span><span class="p">();</span> <span class="n">güncellemeYap</span><span class="p">():</span>
   <span class="n">bedenKısmı</span><span class="p">();</span>
</pre></div>
</div>
<p>Fark ettiyseniz değer tanımlaması beklenen satır yok. Zaten iş yaparken çoğu zaman değerler önceki
satırlarda tanımlanmış olacak.
‘her’ satırı içinde 2 satır tanımlı. Sırasıyla ilk kısım koşul satırı ve bu kısmın koşul olması bir kaide.
İkinci satırda güncelleme kısmı var, sonrasında ise beden satırı ve gizli son satır. Derleyici
Üç satır görecek ve dört satır üretecek.</p>
<p>Göze sade görünüyor. Derleyiciye sade görünüyor ve makina zaten sade görecek.</p>
<dl class="simple">
<dt>not:</dt><dd><p>şunu da eklemek isterim, ilk satırda değer tanımlanması sadece bekleniyor. İllaki değer tanımlayacaksınız
diye bir kaide yok.</p>
</dd>
</dl>
</dd>
<dt id="term-Kosullu-dongu">Koşullu döngü:<a class="headerlink" href="#term-Kosullu-dongu" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">her</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{</span>
   <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;-&gt; </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
   <span class="n">i</span><span class="o">++</span><span class="p">;</span>
   <span class="o">/*</span><span class="n">i</span><span class="s1">&#39;yi güncellemek tamamen isteğe bağlı.*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yazılıma başladığınızda ilk göreceğiniz döngü örneği. Görüldüğü üzere ‘her’ sözcüğünden sonra
koşul var ve bu Örs derleyicisi için şu anlama geliyor: ‘i’ değeri ondan küçükken döngü bedeni çalıştırılacak ve
güncelleme döngü bedeni içerisinde halledilecek ya da halledilmeyecek.</p>
<p>C dilindeki ‘while’ döngüsü ile bire bir aynı kod Örs derleyicisi tarafından üretilecek.</p>
</dd>
</dl>
</dd>
<dt id="term-Tum-dongusu">Tüm döngüsü:<a class="headerlink" href="#term-Tum-dongusu" title="Permalink to this term">#</a></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">tüm</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{</span>
   <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;-&gt; </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
   <span class="n">i</span><span class="o">++</span><span class="p">;</span>
   <span class="o">/*</span><span class="n">i</span><span class="s1">&#39;yi güncellemek tamamen isteğe bağlı.*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ark ettiğiniz üzere yukarıdaki koşullu her döngüsü ile bire bir aynı. Ama ‘tüm’
öngü satırının çeşidi yok. C dilindeki ‘while’ döngüsüne karşılık gelen sade bir döngü satırı.</p>
<p>üm döngüsü için 2 satır istenecek ve sonuç olarak 3 satır makina kodu üretilecek.</p>
</dd>
<dt id="term-Sonuc">Sonuç:<a class="headerlink" href="#term-Sonuc" title="Permalink to this term">#</a></dt><dd><p>‘her’ sözcüğünü döngü satırı tanımlarken seçmemizin amacı türkçede akla yatkın olması.
Türkçenin benzersiz matematiksel doğası var.</p>
<p>Mesela aşağıdaki satırı Türkçeye çevirmeye çalışalım:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">her</span> <span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">:</span>
<span class="p">{</span>
   <span class="n">birşeyler</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>‘i’ değerini 10’a eşitleyip; her bir ‘i’ ondan küçük iken; ‘i’ değerini azaltarak ‘birşeyler’ işlemini çalıştır.</p>
<p>Eğer burada söz dizimine odaklanmazsanız ilginç bir ayrıntıyı yakalayabilirsiniz. Türkçede
diğer pek çok dilin aksine söz dizimi kuralı yok ve bu durum Türkçeye kıvraklık, ifade yeteneği
ve güç katıyor. Yukarıdaki döngü satırını bu denli insan diline bire bir çevireceğiniz ve iyelik ekine kadar makinaya
anlatabileceğiniz nadir dillerden bir tanesi Türkçe.</p>
<p>O yüzden ‘her’ sözcüğünü döngü satırlarını tanımlarken seçtim. Peki her sözcüğünü seçmeseydin ?
Tabi ki de özünde hiç bir önemi yok. İsteserseniz kendi tasarladığınız dilde 124323 sayısını döngü satırları
tanımlamak için bile kullanabilirsiniz.</p>
<p>Basitçe tekrar söylemem gerekirse: “Okuduğumuz kodun, derleyicinin okuduğu kodun ve üretilen kodun olabildiğince örtüşmesini sağlamak.”</p>
<p>Peki buradaki döngü satırlarının makina kodu üretimi konuları diğer yazılım dillerinde öyle değil mi ?</p>
<p>Bazen öyle, bazen değil ve özellikle üretilen kodun iyileştirilme aşamasında boş ya da gereksiz satırlar silinecek.</p>
<p>Burada bu tanımı yapmaktaki amaç
gözümüzün gördüğü kod ile Örs’ün ürettiği kodun olabildiğince örtüşmesi ve
bunun bir kaide olarak belirtilmesi. Yani diyelim ki Örs onuncu sürümünü yayınladı,
bu kaideler değişmeyecek ve bizler nasıl kod üretiyor diye endişelenmeyeceğiz.</p>
<p>Altı çizilmesi gereken diğer konu ise üretilen kodun mümkün olduğunca C dili ile uyumlu olması. Konu döngüler olunca
bu istek önemsiz durabilir; en nihayetinde işlem çağrıları dışında
üretilen kodun diğer kütüphanelerle iletişimi pek olmuyor
ama tepeden tırnağa C dili ile uyum sağlamak Örs’ün tasarım amaçlarından bir tanesi.
Tasarımın merkezi kaidelerinden biri bu ve işletim sistemi kütüphaneleri ile rahat rahat iletişim kurabilmek için bu
kaideyi tepeden tırnağa bozmayacağız.</p>
</dd>
</dl>
</section>
<span id="document-bolumler/tanıtım/satırlar/kosullu_satırlar"></span><section id="kosullu-satirlar">
<h4>Koşullu Satırlar<a class="headerlink" href="#kosullu-satirlar" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Yazılımdaki yönlendirmeleri mantık kullanarak yapabileceğimiz,
sıralı bağlanabilen satırlardır.</p>
<hr class="docutils" />
<p>Koşullu satırların amacı,
yönlendirme satırlarını mümkünse işlev dışı bırakıp,
bu satırları derleyiciye makina dili ile örtülü şekilde ürettirmek,
kodun okunabilirliğini arttırmak, hata ayıklamayı kolaylaştırmaktır.</p>
<p>Koşullu satırlar baş kısımlarında ‘eh’ türlü ya da ‘eh’ türüne çevrilebilen
ifade bekler. Eğer ifade ‘eh’ yapıtaşına çevrilemiyorsa derleyici hata verir.
Sayısal değerler eğer 0 dan farklı ise eksi ya da arto olmasının bir önemi olmaksızın
tıpkı diğer sistem dilllerinde olduğu gibi &quot;evet&quot; yani 1 kabul edilirler; tam tersi durumda ise &quot;hayır&quot;
yani 0 kabul edilir ve çevrilirler.</p>
<p>Konumlar da özlerinde sayısal değer olduklarından;
eğer ki verili konum 0 değilse &quot;evet&quot; kabul edilir
ve konum boş olduğunda ise &quot;hayır&quot; kabul edilirler.</p>
<p>Beden kısımlarında ise herhangi bir satırı kabul ederler.</p>
<p>‘eğer’ satırı yukarıdaki özelliklere uyar, tekil olarak kullanılabilirler
ama diğer koşullu satırlardan
farklı olarak arkasında koşul sağlanmadığında yönlendirebilecekleri
‘eğerki’ ya da ‘değilse’ satırlarını bekleyebilirler.</p>
<p>‘eğerki’ satırı yukarıdaki özelliklere uyar ama tekil olarak kullanılamazlar.
‘eğerki’ satırının aldığı koşul sağlanmadığında yönlendirebileceği
‘eğerki’ veya ‘değilse’ satırlarını beklerler.
‘eğerki’ satırı bedeni tekil satır değilse ve
sonrasında ‘eğer’ satırı gelmişse derleyici hata verir ve süreç durdurulur.</p>
<p>‘değilse’ satırı yukarıdakilerin aksine değerlendirecekleri koşul beklemezler.
Koşulların önceki ‘eğer’ veya ‘eğerki’ satırlarında değerlendirildiklerini
varsayarlar. ‘değilse’ satırı bu doğası gereği tekil olamaz.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">ÇiftMi</span> <span class="n">a</span> <span class="n">tam</span><span class="p">;</span> <span class="n">tam</span><span class="p">:</span>
  <span class="n">eğer</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">dön</span> <span class="n">hayır</span><span class="p">;</span>
  <span class="n">değilse</span><span class="p">:</span>
    <span class="n">dön</span> <span class="n">evet</span><span class="p">;</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte basitçe görüleceği gibi,
eğer ‘a’ değerinin modu bir ise bedenindeki koda yönlenecek
değilse; sıradaki ‘değilse’ satırına yönlecek.</p>
<p>Bu örnekte görüldüğü gibi davranışları C ve benzeri dillerdeki
‘if/else ..’ satırları ile bire bir örtüşür.</p>
</section>
<span id="document-bolumler/tanıtım/satırlar/yönlendirmeler"></span><section id="yonlendirmeler">
<h4>Yönlendirmeler<a class="headerlink" href="#yonlendirmeler" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<section id="islem-yonlendirmeleri">
<h5>İşlem yönlendirmeleri:<a class="headerlink" href="#islem-yonlendirmeleri" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<section id="git-satiri">
<h6>‘git’ satırı:<a class="headerlink" href="#git-satiri" title="Bu başlık için kalıcı bağlantı">#</a></h6>
<p>İşlemciyi isimlendirilmiş kesite yönlendirir.
Genellikle döngüleri yönetilirken kullanılır.
Her ne kadar namı kötü duyulsa da
özellikle anlamlandırılacak metin ağaçlarını
doğrusal alanda işlerken sıklıkla kullanılır.</p>
<p>‘git’ satırı arkasına işlem konumu bekler.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">OnKereYaz</span>
<span class="p">{</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">#kesit1</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;ilk kesit</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="c1">#kesit2</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;ikinci kesit</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">eğer</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">eğer</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">git</span> <span class="n">kesit1</span><span class="p">;</span>
    <span class="n">değilse</span><span class="p">:</span>
      <span class="n">git</span> <span class="n">kesit2</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Bu örnekte sadece nasıl kullanılacağı gösterilmiştir ve
‘git’ satırının uygun kullanımına örnek değildir.
Zira yukarıda ‘her’ döngüsü gerekmektedir. Konu ile alakalı
sağlıklı örnekler metin işleme algoritmalarından verilebilir ama
zaten o algoritmalar dolama gibi olduğundan amacın dışına çıkılacağı düşünülmüştür.</p>
</section>
<section id="don-satiri">
<h6>‘dön’ satırı:<a class="headerlink" href="#don-satiri" title="Bu başlık için kalıcı bağlantı">#</a></h6>
<p>İşlem tanımlandığında belirlenen çıktı olgunlaşınca bu satır ile dönülür.
Boş çıktısı olan işlemler için ifade kabul etmezken, aksi durumlarda ifade ister ve
istenilen ifadenin konumu işletim yığınına konulur.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">ÇiftMi</span> <span class="n">a</span> <span class="n">tam</span><span class="p">:</span> <span class="n">tam</span> <span class="o">=&gt;</span>
  <span class="n">eğer</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">dön</span> <span class="n">hayır</span><span class="p">;</span>
  <span class="n">değilse</span><span class="p">:</span>
    <span class="n">dön</span> <span class="n">evet</span><span class="p">;</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte görüldüğü gibi dönülecek ifadelerin türü ile iş çıktısı aynı olmalıdır.
Aksi takdirde derleyici hata verecektir.</p>
</section>
</section>
<section id="dongu-yonlendirmeleri">
<h5>Döngü yönlendirmeleri:<a class="headerlink" href="#dongu-yonlendirmeleri" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<section id="devam-satiri">
<h6>‘devam’ satırı:<a class="headerlink" href="#devam-satiri" title="Bu başlık için kalıcı bağlantı">#</a></h6>
<p>İstenilen durumlarda döngüyü sonraki devire atlatır.
Tekildir.</p>
</section>
<section id="son-satiri">
<h6>‘son’ satırı:<a class="headerlink" href="#son-satiri" title="Bu başlık için kalıcı bağlantı">#</a></h6>
<p>İstenilen durumlarda döngüyü sonlandırır. Yukarıda tanımlanan ‘git’ satırına
muhalefeten tasarlanmıştır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>iş ÇiftseYazdır:
  her a := 0; evet; a++:
  {
    eğer !(a % 2):
      stdio::printf(&quot;Çift sayı&quot;);
    eğerki a &gt;= 10:
      son;
    değilse:
      devam;
    stdio::printf(&quot;a sayısı tekil olduğunda buraya ulaşılamayacak.&quot;);
  }
</pre></div>
</div>
<p>Gayet okunabilir olan yukarıdaki sonsuz döngüde a çift sayı ise değeri
yazdırılacak, a değeri 9’u aştığında ise ‘son’ yönergesiyle sonladırılacak,
diğer koşulda ise döngüye diğer kesitlere uğranmadan devam edilecek.</p>
</section>
</section>
<section id="durum-yonlendirmeleri">
<h5>Durum yönlendirmeleri:<a class="headerlink" href="#durum-yonlendirmeleri" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<section id="tekrar-satiri">
<h6>‘tekrar’ satırı:<a class="headerlink" href="#tekrar-satiri" title="Bu başlık için kalıcı bağlantı">#</a></h6>
<p>İçinde bulunduğu durum satırını
her bir ‘tekrar’ satırına uğranış için çalıştırır.</p>
</section>
<section id="gec-satiri">
<h6>‘geç’ satırı:<a class="headerlink" href="#gec-satiri" title="Bu başlık için kalıcı bağlantı">#</a></h6>
<p>İçinde bulunduğu seçim satırının ardılı olan seçim satırına
atlamak için kullanılır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">HarfseYaz</span> <span class="n">_girdi</span> <span class="o">*</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">durum</span> <span class="n">_girdi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">{</span>
    <span class="n">seçim</span> <span class="n">ascii</span><span class="p">::</span><span class="n">Boş</span><span class="p">:</span>
      <span class="n">dön</span><span class="p">;</span>
    <span class="n">seçim</span>
      <span class="n">ascii</span><span class="p">::</span><span class="n">küçükler</span><span class="p">,</span>
      <span class="n">ascii</span><span class="p">::</span><span class="n">büyükler</span><span class="p">,</span>
      <span class="n">ascii</span><span class="p">::</span><span class="n">Alt_Tire</span><span class="p">:</span>
        <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_girdi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">geç</span><span class="p">;</span>
      <span class="n">varsayılan</span><span class="p">:</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">tekrar</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte _girdi ascii harfi dizisindeki okunabilir
olanlar yazılacak,
ve sonraki varsayılan satırında sırası arttırılıp durum ‘ascii::Boş’ sabitini görene kadar
tekrar değerlendirilecek.</p>
</section>
</section>
</section>
<span id="document-bolumler/tanıtım/satırlar/durum"></span><section id="durum-ve-secimler">
<h4>Durum ve Seçimler<a class="headerlink" href="#durum-ve-secimler" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Dijital tasarımın özü. Hadi şu “dijital” kelimesinden kurtulalım.
Zira herkesin aklına fotoğraf makinesi geliyor.
Sayısal tasarımın özü: Durumlar.</p>
<hr class="docutils" />
<p>Durum satırlarının amacı sabit sayı ile ilişkilendirilmiş satırları çalıştırmaktır.
<strong>Düz mantıkla</strong> şunu söyleyebiliriz ki derleyici kod kesitlerini diziye koyuyor ve
işlemci ise erişilen dizideki kodu çalıştırıyor olarak <strong>kabaca</strong> anlaşılabilir.
Özlerinde sıralı kod kesitleri oldukları
için matematikteki, işlevsel dillerdeki benzer kavramlarla örtüşmezler.</p>
<p>Durum satırı baş kısmında tam sayı, özel olarak ‘t32’, yapıtaşını bekler ve eğer satırdaki ifade
‘t32’ değilse üretim aşamasında ‘t32’ türüne çevrilir. Özetle eğer siz durumunu seçmek için türü d64 olan
bir ifade kullandığınızda bu siz çeviri yapsanız da yapmasanız da derleyici tarafından ‘t32’ türüymüşcesine algılanır ve
çeviri yapmadığınız taktirde kendisi çevirir.
Bu kısım özellikle ‘sayaç’ kavramı ile bağlantılıdır. Hatırlarsanaz sayaçlar da
üye olarak sadece ‘t32’ sabitleri bekler.</p>
<p>Beden kısmında ise <strong>seçim</strong> satırları yer alır.
Seçim satırına dahil olmayan satırlar varolduğu taktirde derleyici tarafından
gereksiz görülecek ve silinecektir.
Seçimler sabit sayılar, sabit sayı dizileri ve sayaç kümeleri beklerler.
Değişken bir ifadenin seçim satırı olamaz. Eğer seçim satır başlarında verili ifadeler sabit değilse; derleyici hata verir ve üretimi durdurur.
En nihayetinde üretilecek olan kod kesitini değişen sıraya koymanın ne imkanı ne de anlamı vardır.</p>
<p>Seçimler beden olarak seçim satırı hariç her herhangi bir satırı kabul ederler.
Bu uygulamada şu anlama gelir:
İki seçim sıralandığı takdirde sonraki gelen öncekinin devam kesiti değildir.
Aşağıda örnekle tekrar belirteceğiz.</p>
<p>‘<strong>varsayılan</strong>’ satırı özel isimlendirilmiş bir seçim satırıdır.
Seçmediğiniz tüm durumlar için varsayılan satırında seçilir. Adı üzerinde bizim ele almadığımız durumlarda
yazılımın varsayılan davranışını belirler. Eğer durum satırlarınızda ‘varsayılan’ seçimi belirtmediğiğniz taktirde
derleyici sizin varsayılan seçim için boş satır (yani: ‘{}’ simgesi ile belirtilen satır)
seçtiğinizi algılar.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">DurumÖrneği</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">gelen</span> <span class="n">tam</span> <span class="o">=</span> <span class="n">Sıfırİle10ArasındaRastgeleSayı</span><span class="p">();</span>

  <span class="n">durum</span> <span class="n">gelen</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">seçim</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;0 geldi.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">seçim</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;2 geldi ve sıradaki seçime geçildi.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
      <span class="n">geç</span><span class="p">;</span>
    <span class="n">seçim</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;1 geldi.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">seçim</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;3 &lt;= durum &lt;= 6 geldi.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">varsayılan</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Seçilmeyen bir durum geldi.&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="o">//</span><span class="n">durumSatırıSonu</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;örnek tamamlandı.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte gelen sayısına sıfır ve 10 dahil ama arasında bir değeri atandı.
Bu dakidan sonra yapılacak olan şey sizin belirlediğiniz seçim satırlarını çalıştırmak.
Seçim satırları yönlendirilmediği taktirde durum satırı sonuna geçecekler ve görevlerini tamamlayacaklar.</p>
<p>Altını çizerim bu C’deki 'switch/case' satırlarından oldukça farlı ki zaten isim değişikliğinin nedeni bu farklılık.
Eğer özel olarak belirtilmezse C dilindeki seçim satırları sıradaki satıra geçiyor. Cidden çok sıkıntılı ve tehlikeli bir özellik.
Bazı durumlarda gözden kaçan, veya koymayı unuttuğunuz tek bir yönergenin neden olduğu hataları ayıklamak saatler alabiliyor. Dahası
Dahası bazı durumlarda hatayı aylarca fark etmiyorsunuz ve ummadığınız bir zamanda başınıza bela olabiliyor.</p>
<p>İkinci seçimde ise çok özel <strong>'geç'</strong> satırımız var.
Gelen sayı 2 olduğunda ‘seçim 2’ satırı çalıştırılacak ama durum sonuna atlamak yerine
‘seçim 1’ satırına geçecek ve tabi ki ‘seçim 1’ satırı işi bitince durum sonuna atlayacak.</p>
<section id="durum-dongusu">
<h5>Durum döngüsü:<a class="headerlink" href="#durum-dongusu" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Özellikle metin işleme ya da oyun yazılımlarında çok karşılaşacağınız bir sorun.
Belirlediğiniz duruma kadar döngü devam etsin istiyorsunuz.
Sanal makinalarda genellikle sıfır durumuna kadar döngü bitsin istemiyorsunuz. Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">BelgeYaz</span> <span class="n">_yol</span> <span class="o">*</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="n">Belge</span> <span class="o">:=</span> <span class="n">belge</span><span class="p">::</span><span class="n">bayt</span><span class="p">::</span><span class="n">Yeni</span><span class="p">(</span><span class="n">_yol</span><span class="p">);</span>
  <span class="n">eğer</span> <span class="n">Belge</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">sıra</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">durum</span> <span class="n">Belge</span><span class="o">.</span><span class="n">Dizi</span><span class="p">[</span><span class="n">sıra</span><span class="p">]:</span>
    <span class="p">{</span>
      <span class="n">seçim</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">varsayılan</span><span class="p">:</span>
        <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%c</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">Belge</span><span class="o">.</span><span class="n">Dizi</span><span class="p">[</span><span class="n">sıra</span><span class="o">++</span><span class="p">]);</span>
        <span class="n">tekrar</span><span class="p">;</span> <span class="o">//</span><span class="n">can</span> <span class="n">alıcı</span> <span class="n">kısmı</span><span class="o">.</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">değilse</span><span class="p">:</span>
    <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> belgesinin içeriği okunamadı.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Burada yapılan iş basitçe ilkin belge bayt olarak açıldıktan sonra
bayt dizisine erişiliyor. Belge sonlarında sıfır olduğu için ‘seçim 0’ durum sonuna atlayıp devam edecek.
Diğer tüm seçimler için ise, sıradaki harfi yazdırıp sonra durumu tekrar edecek.
‘tekrar’ sözcüğünün örs için anlamı bu.</p>
<p>Doğal olarak sadece seçim satırlarında yer alabilir ve kümelenmiş durum satırlarında
‘tekrar’ satırı kullanıldığında en son durum satırına atıfta bulunur ve oraya atlar.
Bunun dışındaki yerlerde tekrar yönerge satırı anlamsızdır ve hatalıdır.
Derleyici uygun kod ile işlemi hatalı sonlandıracaktır.</p>
<p>Şu denilebilir ki “Bu çok tehlikeli bir özellik, ne gereği vardı, döngü kullanılarak da başarılabilirdi” vs.
Hepsine &quot;Evet haklısınız&quot; diyorum ama yukarıda
belirttiğim gibi bu biraz elinizdeki soruna yönelik bir çözüm.
Belirttiğim gibi tekrar satırı metin çözümleme
ve oyun tasarımı gibi alanlarda anlamlı ve üretken çözümler sunar.</p>
<p>Döngülerde özellikle her döngüsünde baş satırlar anlamlı olduğu için
işlem gücüne mâl olur. Metin sorunları ise doğaları gereği hız isteyenler olduğundan
her bir küçük işlemden bile olabildiğince kurtulup hızın sıkıp suyunu çıkarmamız gereken durumlarda
Durum döngüleri anlamlı olur.</p>
<p>Tekrar belirtmek isterim gündelik durumlarda beklenmeyen, tehlikeli sonuçlara yol açabilir.
En nihayetinde eğer döngü varsa bunu yönergelerle değil döngü satırları ile sağlamak
hem okunabilirlik, hem sadelik ilkelerinin taleplerini sağlamak bakımından önemlidir.</p>
<p>Durum ve seçim satırları görevleri gereği C dilindeki ‘switch/state’, işlevsel dillerdeki
‘the guards’ kavramlarına benzer. Yukarıdaki farklılığı belirtmek adına kavramları doğrudan
çeviri yöntemiyle isimlendirmek uygun görülmedi. Diğer dillerde ve Örs dilinde
ifadenin durumuna göre seçim yapıldığı için konuşma dilindeki sözcüklerden ilham alındı.</p>
</section>
</section>
</div>
</section>
<span id="document-bolumler/tanıtım/hafıza"></span><section id="hafiza">
<h3>Hafıza<a class="headerlink" href="#hafiza" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<section id="yeni">
<h4>Yeni:<a class="headerlink" href="#yeni" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>İşletim sisteminden istenilen boyutta yeni hafıza
konumu istemek için kullanılan ifadedir. Sadece ve sadece
tür ifadesini kabul ederler ve diğer ifadelerin ise türünü alıp
ona göre işlevlerini gerçekleştirirler. Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">Sayılar</span> <span class="o">*</span><span class="n">tam</span> <span class="o">=</span> <span class="n">yeni</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
<span class="o">//</span> <span class="mi">20</span> <span class="n">X</span> <span class="mi">4</span> <span class="n">baytlık</span> <span class="n">dizinin</span> <span class="n">konumunu</span> <span class="n">dönecek</span>
<span class="o">//</span> <span class="n">ve</span> <span class="n">bu</span> <span class="n">konum</span> <span class="n">sayılar</span> <span class="n">değerinde</span> <span class="n">tutulacak</span><span class="o">.</span><span class="n">x</span>
<span class="n">değer</span> <span class="n">Matriks</span> <span class="o">**</span><span class="n">tam</span> <span class="o">=</span> <span class="n">yeni</span><span class="p">(</span><span class="o">%</span><span class="n">Sayılar</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
<span class="o">//</span> <span class="n">Sayılar</span> <span class="n">değerinin</span> <span class="n">türü</span> <span class="n">bir</span> <span class="n">konum</span> <span class="n">olduğu</span> <span class="n">için</span>
<span class="o">//</span> <span class="p">(</span><span class="n">konum</span> <span class="n">genişliği</span><span class="p">)</span> <span class="n">x</span> <span class="mi">20</span> <span class="n">baytlık</span> <span class="n">bir</span> <span class="n">konum</span> <span class="n">dizisi</span> <span class="n">dönecek</span> <span class="n">ve</span> <span class="n">matriks</span> <span class="n">olacak</span><span class="o">.</span>
<span class="o">//</span> <span class="n">ama</span> <span class="n">farkettiğiniz</span> <span class="n">üzere</span> <span class="n">matriksin</span> <span class="n">satırları</span> <span class="n">boş</span><span class="o">.</span>
<span class="n">değer</span> <span class="n">DoluMatriks</span> <span class="o">**</span><span class="n">tam</span> <span class="o">=</span> <span class="n">yeni</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]);</span>
<span class="o">//</span> <span class="n">bu</span> <span class="n">satırda</span> <span class="n">ise</span> <span class="n">yeni</span> <span class="n">ifadesi</span> <span class="mi">20</span><span class="n">x20</span><span class="s1">&#39;lik tam sayı matriksi oluşturdu.</span>
</pre></div>
</div>
<p>Yeni ifadesinin C dilindeki karşılığı hepimizin bildiği malloc işlemidir. Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">Sayılar</span> <span class="o">*</span><span class="n">tam</span> <span class="o">=</span> <span class="n">yeni</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
<span class="o">//</span> <span class="n">yukarıdaki</span> <span class="n">Örs</span> <span class="n">satırı</span> <span class="n">ile</span><span class="p">;</span> <span class="n">aşağıdaki</span>
<span class="nb">int</span><span class="o">*</span> <span class="n">Sayılar</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="n">sizedf</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="o">//</span> <span class="n">C</span> <span class="n">satırı</span> <span class="n">özlerinde</span> <span class="n">bire</span> <span class="n">bir</span> <span class="n">aynıdır</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="temiz">
<h4>Temiz:<a class="headerlink" href="#temiz" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Yeni ifadesinden sonra işletim sisteminin yazılıma tahsis edeceği
hafızanın içeriği bilinemez. Bu yüzden genelde C dilinde yazarken
hafıza ayrıldıktan sonra onu temizleriz.
Tam bu noktada temiz ifadesi anlamlı oluyor. Mesela yukarıdaki örneği tekrar
ele alalım:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">Sayılar</span> <span class="o">*</span><span class="n">tam</span> <span class="o">=</span> <span class="n">temiz</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
</pre></div>
</div>
<p>Bu örnekte ise temiz ifadesinin anlamı 20X4 bayt genişliğinde
sıfırlanmış tam sayı dizisidir.</p>
</section>
<section id="yenile">
<h4>Yenile:<a class="headerlink" href="#yenile" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>İşletim sistemi tarafından öncesinde ayrılmış kaynağı daraltmak
ya da genişletmek için kullanılır. C dilindeki karşılığı realloc işlemidir.</p>
<p>Sil:
^^^
İşletim sisteminin bize verdiği kaynağın görevi sona erdikten sonra
eğer ki bilgisayar hafızasının veri çöplüğüyle dolmasını istemiyorsak;
kaynağı sahibine geri vermemiz gerekiyor.</p>
<p>‘Sil’ imgesi bir satırdır ve bir değer dönmez.</p>
<p>Silinen konum değerleri boşlanır. Yani konumun yeni sayısal değeri 0’dır.</p>
<p><strong>Mesela</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">Sayılar</span> <span class="o">*</span><span class="n">tam</span> <span class="o">=</span> <span class="n">temiz</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
<span class="n">her</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nd">@tam</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;0 mı : </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Sayılar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
<span class="o">/*</span>
  <span class="n">sıfır</span> <span class="n">olduğunu</span> <span class="n">gösterdik</span> <span class="n">ve</span> <span class="n">işimiz</span> <span class="n">bitti</span><span class="p">,</span>
  <span class="n">şimdi</span> <span class="n">kaynağı</span> <span class="n">geri</span> <span class="n">verme</span> <span class="n">zamanı</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">sil</span> <span class="n">Sayılar</span><span class="p">;</span>
<span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Sayılar değerindeki konum : %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">Sayılar</span><span class="p">);</span>
<span class="o">/*</span>
  <span class="n">Canlı</span> <span class="n">hata</span> <span class="n">verilmediyse</span> <span class="n">arayüzde</span> <span class="p">:</span>
  <span class="s2">&quot;Sayılar değerindeki konum : (nil)&quot;</span>
  <span class="n">gibi</span> <span class="n">bir</span> <span class="n">çıktı</span> <span class="n">alınacaktır</span><span class="o">.</span>
<span class="o">*/</span>
</pre></div>
</div>
</section>
<section id="bosalt">
<h4>Boşalt:<a class="headerlink" href="#bosalt" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Görevi basitçe konuma gidip içeriğini sıfırlamaktır.
İki farklı söz dizimi vardır. İlk söz diziminde;
İlk değişkeni konumken,
ikincisi boşaltırken o konumda ne kadar ilerleyeceği bilgisidir.</p>
<p>Boşalt imgesi bir satırdır.</p>
<p><strong>Mesela</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">Sayılar</span> <span class="o">*</span><span class="n">tam</span> <span class="o">=</span> <span class="n">yeni</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
<span class="n">boşalt</span> <span class="n">Sayılar</span><span class="p">,</span> <span class="mi">20</span><span class="p">;</span>
</pre></div>
</div>
<p>Sayılar dizisindeki tüm tam sayı hücrelerini boşalt satırı sıfırlayacaktır.</p>
<p>İkinci söz dizisi ise tekildir. Konum alıp değerini sıfırlar.</p>
<p><strong>Mesela</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">değer</span> <span class="n">Sayılar</span> <span class="o">*</span><span class="n">tam</span> <span class="o">=</span> <span class="n">yeni</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
<span class="n">boşalt</span> <span class="o">&amp;</span><span class="n">Sayılar</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>Bu örnekte ise yukarıdakinin aksine sadece 2 nolu hücredeki tam sayı boşaltılmıştır.</p>
<p>Konumu ve türü bilinen herşey sıfırlanabilir.
Burada dikkat edilmesi gereken türün boyutu ve canlılığıdır.
Canlı ayrılan kaynaklarda eğer ki ne kadar kaynak ayrıldığı biliniyorsa
sorun olmaz ama bilinmiyorsa ve işletim sistemi tarafından belirlenin alanın
dışına taşılmışsa işletim sistemi hata verir ve yazılımı ‘SIGSEV’ koduyla sonlandırır.</p>
</section>
</section>
<span id="document-bolumler/tanıtım/islemler"></span><section id="islemler">
<h3>İşlemler<a class="headerlink" href="#islemler" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<p>Eğer belirgin bir görevi yerine getiren satır kümesi var ise
bu satır kümesine mantıken işlem denilebilir.</p>
<p>Örs dilinde işlemler sıralı satır kümesi olarak tanımlanır.
Haskell, Ocaml vb. dillerin aksine Örs, C, C++ işlevsel değil; sıralı bir dildir.
Tasarım, Örs işlemlerinin görevi ve işlevi olduğunu varsayar.
Bu konuda yanlış anlaşılmamak gerçekten önemli. Zira yeni öğrenenler
sıralı dillerdeki işlem kavramının matematikteki işlem kavramı olduğunu ister istemez
düşünüyor. Oysa bilgisayara matematik işlemini tanıtmakla işlevi yerine getirmek bambaşka konular.
Yani Örs bire bir lambda matematiği ile örtüşmez. Bunun tasarım nedenleri başlı başına
ayrı bir konu ve burada bizi ilgilendiren kavram Örs ve
diğer benzeri sistem dillerinde işlemlerin ele alınışının
matematikteki işlem (fonksiyon) kavramı ile aynı olmadığıdır.</p>
<p>İşlemler Örs dilinde satır değildir ama beden olarak satır bekler.</p>
<dl class="glossary">
<dt id="term-Sade-islemler"><strong>Sade işlemler:</strong><a class="headerlink" href="#term-Sade-islemler" title="Permalink to this term">#</a></dt><dd><p>Girdisi ve çıktısı olmayan işlemlere sade işlemler Örs dilinde aşağıdaki gibi tanımlanır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">Merhaba</span><span class="p">:</span>
<span class="p">{</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Merhaba Dünya !&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Örnekte görüldüğü üzere;
işlemler tanımlanırken ‘iş’ sözcüğü kullanılarak başlanır.
Sonrasında işin derleme birimindeki benzersiz adı verilir ve son olarak ise beden satırı tanımlanır.</p>
<p>Kısa yol olarak tek satırlık işlemler de aşağıdaki gibi tanımlanabilir.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">Merhaba</span><span class="p">:</span>
<span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Merhaba Dünya !&quot;</span><span class="p">);</span>

<span class="o">/*</span><span class="n">ya</span> <span class="n">da</span><span class="o">*/</span>

<span class="n">iş</span> <span class="n">DöngülüMerhaba</span><span class="p">:</span>
  <span class="n">her</span> <span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Merhaba Dünya !&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Bu örnekte sadece tek satırlı işler tanımlayabilme yeteneğindeki amaç
okunurluğu sade ve kolay kılmaktır.</p>
</dd>
<dt id="term-Degiskenler"><strong>Değişkenler:</strong><a class="headerlink" href="#term-Degiskenler" title="Permalink to this term">#</a></dt><dd><p>İşlemlerin girdileri ve çıktıları olabilir.</p>
<div class="admonition note">
<p class="admonition-title">Not</p>
<p>Örs veyâ diğer sıralı dillerdeki değişkenler kavramı
matematikteki bağımlı ve bağımsız değişkenlerle karıştırılmamalıdır.
Sıralı diller makinaya yakın olduğu için; üretilmiş makina kodu
işletim sisteminin işlem yığınına alınacak ve bu aşamada matematikteki
kavramlar yozlaşmaya uğruyor. O yüzden <strong>değişkenler</strong> kavramını kendi
içerisinde ele almak daha sağlıklı.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">;</span> <span class="n">tam</span><span class="p">:</span>
<span class="p">{</span>
  <span class="n">dön</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Derleyiciye bu işlemin baş kısmıyla denilen şey basitçe:
“a ve b tam sayı değişkenleri kabul edip, tam sayı dönen ‘Topla’ işini tanımla.”</p>
<p>Değişkenler tanımlı işin beden satırında değer gibi ele alınsalar da; hem derleyici tarafından
yorumlanması hem de bilgisayarda işlenmesi bakımından özlerinde değerlerden farklılardır.</p>
<p>On altı farklı girdi değişkeni ve tek bir çıktı değişkeni tanımlanabilir.</p>
<p>Burada değişken sayısının üst sınırının 16 olmasının nedeni basitçe uygunluğudur.
Bildiğim kadarı ile GNU C dilinde 255 farklı değişken tanımlanabiliyor ama Clang derleyicisi farklı ele alıyor olabilir.
Diyelim sadece iki değişken
kabul etseydi o zaman <strong>türleri</strong> kullanarak dilediğimiz kadar değişkeni tek seferde bile işlemek mümkün olurdu.
Bu nedenden ötürü burada önemli olan değişken tanımlarında bir üst sınır olduğudur.
Zira ben bu güne kadar 16 değişkeni olan bir işlem görmedim.</p>
<dl>
<dt><strong>Çıktılar:</strong></dt><dd><p>Yukarıdaki ‘Topla’ işlemine küçük bir değişiklik yapalım:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">;</span> <span class="n">dönüş</span> <span class="n">tam</span><span class="p">:</span>
  <span class="n">dön</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
<p>Derleyiciye emredilen yine değişmedi ama Örs dilinde çıktılara isimlendirdiğimiz sürece erişebiliriz.
Bu <strong>go</strong> ve benzeri dillerin bizimle tanıştırdığı harika bir özellik. İşlemler içerisinde pek çok sefer
döneceğimiz değeri tanımlamak zorunda kalıyoruz. Gerek bile yok. Çıktısı olan işlemlerde
zaten dönülecek türün hafızası önceden ayrılıyor ve tekrar başka bir dönüş değeri tanımladığımızda iyileştirme aşamasında
doğal olarak siliniyor çünkü gereksiz bir değer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">;</span> <span class="n">dönüş</span> <span class="n">tam</span><span class="p">:</span>
<span class="p">{</span>
  <span class="n">dönüş</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">/*</span><span class="n">ya</span> <span class="n">da</span> <span class="n">tek</span> <span class="n">satırlık</span> <span class="n">tanımla</span><span class="o">*/</span>

<span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">;</span> <span class="n">dönüş</span> <span class="n">tam</span><span class="p">:</span>
  <span class="n">dönüş</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<hr class="docutils" />
<p>İşlem baş kısmı özet olarak yukarıdaki gibidir.
Örs dilinde işlemler tanımlanırken ‘iş’ sözcüğü kullanılarak başlanır.
Sonrasında işin birim hafızasındaki benzersiz adı verilir,
eğer varsa değişkenler aralarına virgül konularak tanımlanır
ve eğer varsa çıktı kısmı girdilerden ayırmak için çift nokta ile ayrılır
ve son olarak ise satırı tanımlanır.
Makina dili yapılanması
C dilinin derlendiği işletim sistemleri için belirlediği standartlara uyar.</p>
<section id="iskelet">
<h4>İskelet:<a class="headerlink" href="#iskelet" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<blockquote>
<div><p><strong>Hazırlanıyor.</strong></p>
</div></blockquote>
<p>Beden kısmına ise her biri sıralı ifadelerin kümesi olan satırların olduğu sıralı küme satırı kabul eder.</p>
<p>İşlemler konusunu irdelemeyi <strong>türler</strong> ve <strong>birimler</strong> konularını ele alana kadar burada bırakmak zorundayız.</p>
</section>
</section>
<span id="document-bolumler/tanıtım/turler"></span><section id="turler">
<h3>Türler<a class="headerlink" href="#turler" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<div class="toctree-wrapper compound">
<span id="document-bolumler/tanıtım/turler/yapıtasları"></span><section id="yapitaslari">
<h4>Yapıtaşları<a class="headerlink" href="#yapitaslari" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Örs dilinde hafızada konumlandırabileceğiz en küçük anlamlı parçalardır.</p>
<p>Konumlandırabileceğiz diyoruz zira türleri üyelerine ayrıştırınca
öyle bir noktaya erişiyoruz ki daha fazla parçalamak yazılımda
verim, hız, bütünlük gibi sorunlara yol açıyor.</p>
<p>Bu noktada yazılım dilleri tüm tanımlanabilir türlerin
temel alacağı yapıtaşları belirler.</p>
<p>Bunu yaparlarken genelde güttükleri kaygı uyumluluk üzerinedir.
Mesela işlem çağrılarını birbirine giren parçalar olarak hayal edin.
Eğer parçalar belli bir ölçüye uymuyorlarsa beraber çalışmaları zorlaşır ve hatta imkansızlaşır.
Bu noktada işlemciler tarafından belirlenen mimarilere uymak
ve tür temelinde genel uyumu yakalamak önemlidir. Bu mânada;
hayalen dilediğiniz bit genişliğine sahip yapıtaşlarını hem makina dili
hem de yazılım dili seviyesinde tanımlamak tamamen mümkündür.
Sistem dilleri için sorun bu bit genişliğinin işlemci mimarisi ile uyumlu olup olmadığıdır.
Zira hedefi makina kaynaklarına sağlıklı erişim olan dillerin; mimari uyumsuzluğu yüzünden
hız ve verim sorunlarına katlanmasını beklemek biraz anlamsızdır.</p>
<p>Yukarıdaki uyum sorunu cidden önemli çünkü aynı zamanda yazılımımızı dış dünyaya
bu yapıtaşlarının ele alanışı üzerinden belirliyoruz. Eğer derleyici tarafından
belirlenen genişlikler yaygın kullanıma uymuyorsa, iki iletişim kaynağının
arasına görevi çevirmenlik yapmak olan bir yazılımı eklemek zorunda kalıyoruz.</p>
<p>Bu yüzden Örs yapıtaşları konusunda C’dili ile bire bir uyumluluk siyasetini güder.
C dilinde bile derleyiciden derleyiciye değişen ve hatta sürümler arası farklar olan
bir konuyu daha da karmaşıklaştırmak anlamsız ve gereksizdir.</p>
<p>En nihayetinde gerçek hayatta yazılımdaki görevleri bir araya getirerek türler oluşturmaktır ki
kendileri de aynı zamanda türdür. Türlerden farkı en küçük anlamlı konumladırılabilir parçalar olmasıdır.
Onun dışında türlerle aynı davranışları sergilerler.</p>
<p>Aşağıda Örs dilinde tanımlı yapıtaşlarına ve C’deki denklerine ulaşabilirsiniz.</p>
<dl>
<dt>Tanımlı yapıtaşları:</dt><dd><table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 31%" />
<col style="width: 31%" />
<col style="width: 13%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Yapıtaşları</strong></p></th>
<th class="head"><p>Bit genişliği</p></th>
<th class="head"><p>Alt sınır</p></th>
<th class="head"><p>Ust sınır</p></th>
<th class="head"><p>İşaretli mi</p></th>
<th class="head"><p>C’deki karşılığı</p></th>
<th class="head"><p>Biçimlendirme</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Tam Sayılar</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>t8</strong></p></td>
<td><p>8 bit</p></td>
<td><p>-127</p></td>
<td><p>128</p></td>
<td><p>evet</p></td>
<td><p>char</p></td>
<td><p>%c</p></td>
</tr>
<tr class="row-even"><td><p><strong>t16</strong></p></td>
<td><p>16 bit</p></td>
<td><p>-32,768</p></td>
<td><p>32,767</p></td>
<td><p>evet</p></td>
<td><p>short</p></td>
<td><p>%hd</p></td>
</tr>
<tr class="row-odd"><td><p><strong>t32</strong></p></td>
<td><p>32 bit</p></td>
<td><p>-2,147,483,648</p></td>
<td><p>2,147,483,647</p></td>
<td><p>evet</p></td>
<td><p>int</p></td>
<td><p>%d</p></td>
</tr>
<tr class="row-even"><td><p><strong>t64</strong></p></td>
<td><p>64 bit</p></td>
<td><p>-2^63</p></td>
<td><p>2^63</p></td>
<td><p>evet</p></td>
<td><p>int64_t</p></td>
<td><p>%lld</p></td>
</tr>
<tr class="row-odd"><td><p><strong>t128</strong></p></td>
<td><p>128 bit</p></td>
<td><p>-2^127</p></td>
<td><p>2^127</p></td>
<td><p>evet</p></td>
<td><p>__int128_t</p></td>
<td><p>%lld*</p></td>
</tr>
<tr class="row-even"><td><p><strong>tam</strong></p></td>
<td><p>32 bit</p></td>
<td><p>-2,147,483,648</p></td>
<td><p>2,147,483,647</p></td>
<td><p>evet</p></td>
<td><p>int</p></td>
<td><p>%d</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Doğallar</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>d8</strong></p></td>
<td><p>8 bit</p></td>
<td><p>0</p></td>
<td><p>255</p></td>
<td><p>hayır</p></td>
<td><p>uint8_t</p></td>
<td><p>%c</p></td>
</tr>
<tr class="row-odd"><td><p><strong>d16</strong></p></td>
<td><p>16 bit</p></td>
<td><p>0</p></td>
<td><p>65,535</p></td>
<td><p>hayır</p></td>
<td><p>uint16_t</p></td>
<td><p>%hu</p></td>
</tr>
<tr class="row-even"><td><p><strong>d32</strong></p></td>
<td><p>16 bit</p></td>
<td><p>0</p></td>
<td><p>4,294,967,295</p></td>
<td><p>hayır</p></td>
<td><p>uint32_t</p></td>
<td><p>%u</p></td>
</tr>
<tr class="row-odd"><td><p><strong>d64</strong></p></td>
<td><p>64 bit</p></td>
<td><p>0</p></td>
<td><p>2^64</p></td>
<td><p>hayır</p></td>
<td><p>uint64_t</p></td>
<td><p>%llu</p></td>
</tr>
<tr class="row-even"><td><p><strong>d128</strong></p></td>
<td><p>128 bit</p></td>
<td><p>0</p></td>
<td><p>2^128</p></td>
<td><p>hayır</p></td>
<td><p>__uint128_t</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>doğal</strong></p></td>
<td><p>32 bit</p></td>
<td><p>0</p></td>
<td><p>4,294,967,295</p></td>
<td><p>evet</p></td>
<td><p>uint32_t</p></td>
<td><p>%u</p></td>
</tr>
<tr class="row-even"><td><p><strong>Ondalıklar</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>o32</strong></p></td>
<td><p>32 bit</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>float</p></td>
<td><p>%f</p></td>
</tr>
<tr class="row-even"><td><p><strong>o64</strong></p></td>
<td><p>64 bit</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>double</p></td>
<td><p>%lf</p></td>
</tr>
<tr class="row-odd"><td><p><strong>o128</strong></p></td>
<td><p>128 bit</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>%Lf</p></td>
</tr>
<tr class="row-even"><td><p><strong>ondalık</strong></p></td>
<td><p>64 bit</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>double</p></td>
<td><p>%lf</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Özel</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>mimari</p></td>
<td><p>işlemci</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>hayır</p></td>
<td><p>size_t</p></td>
<td><p>%lu</p></td>
</tr>
<tr class="row-odd"><td><p>şey</p></td>
<td><p>işlemci</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>~</p></td>
<td><p>void*</p></td>
<td><p>%p</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</section>
<span id="document-bolumler/tanıtım/turler/sayac"></span><section id="sayac">
<h4>Sayaç<a class="headerlink" href="#sayac" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Örs dilinde konumlandırılamayan türlerdendir.</p>
<p>Konumları alınamaz çünkü aslında kaynak kodunu anlamlı
kılmak adına kümelendirilmiş sabit 32 bit genişliğinde tam
sayılar <strong>kümesidir.</strong></p>
<p>Tüm yazılım dillerinde farklı söz dizimleriyle bulunan bir kavramdır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sayaç</span> <span class="n">Rakam</span>
<span class="p">{</span>
  <span class="n">Sıfır</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Bir</span><span class="p">;</span>
  <span class="n">İki</span><span class="p">;</span>
  <span class="n">Üç</span><span class="p">;</span>
  <span class="n">Dört</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">Beş</span><span class="p">;</span>
  <span class="n">Altı</span><span class="p">;</span>
  <span class="n">Yedi</span><span class="p">;</span>
  <span class="n">Sekiz</span><span class="p">;</span>
  <span class="n">Dokuz</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte C dilindeki ‘enum’ kavramından farklı değil.
Atamalardan sonra diğer üyeler birer arttırılarak değerlenecek.
C dilinden farkı sayaçların üye olarak sayaç üyelerini kabul eden kümeleri de kabul etmesidir.
Çünkü sayaçlar yazılımda ‘durum’ kavramının tamamlayıcılarıdır ve
bazen farklı durumlar için aynı seçim satırını kullanabiliriz.
Tam bu noktada birden çok seçim satırını tekrar tekrar yazmak sadece
kalabalık oluşturuyor ve okumayı güçleştiriyor. Bu noktada
yardıma sayaç kümeleri yetişiyor. Mesela yukarıdaki örneği tekrar yazalım:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sayaç</span> <span class="n">Rakam</span>
<span class="p">{</span>
  <span class="n">Sıfır</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Bir</span><span class="p">;</span>
  <span class="n">İki</span><span class="p">;</span>
  <span class="n">Üç</span><span class="p">;</span>
  <span class="n">Dört</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">Beş</span><span class="p">;</span>
  <span class="n">Altı</span><span class="p">;</span>
  <span class="n">Yedi</span><span class="p">;</span>
  <span class="n">Sekiz</span><span class="p">;</span>
  <span class="n">Dokuz</span><span class="p">;</span>

  <span class="n">tekler</span><span class="p">(</span><span class="n">Bir</span><span class="p">,</span> <span class="n">Üç</span><span class="p">,</span> <span class="n">Beş</span><span class="p">,</span> <span class="n">Yedi</span><span class="p">,</span> <span class="n">Dokuz</span><span class="p">);</span>
  <span class="n">çiftler</span><span class="p">(</span><span class="n">Sıfır</span><span class="p">,</span> <span class="n">İki</span><span class="p">,</span> <span class="n">Dört</span><span class="p">,</span> <span class="n">Altı</span><span class="p">,</span> <span class="n">Sekiz</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Burada tek ve çift sayılar tekrar kümelenmiş ki kullanımlarında kolaylık olsun.
Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">RakamTekMiÇiftMi</span> <span class="n">a</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">durum</span> <span class="n">a</span>
  <span class="p">{</span>
    <span class="n">seçim</span> <span class="n">Rakam</span><span class="p">::</span><span class="n">tekler</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Tek rakam: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">seçim</span> <span class="n">Rakam</span><span class="p">::</span><span class="n">çiftler</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Çift rakam: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">varsayılan</span><span class="p">:</span>
      <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Gelen sayı </span><span class="si">%d</span><span class="s2"> bir rakam değil !</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıdaki örnekte okuma kolaylığını görebiliyorsunuz. Sayaç kümeleri burada
kodu daha sade ve okunabilir kılmış ki gerçek hayatta bu durumu bolca kullanıyoruz.</p>
</section>
<span id="document-bolumler/tanıtım/turler/tur"></span><section id="turler">
<h4>Türler<a class="headerlink" href="#turler" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>İşlemler nasıl bilgisayar dünyasının kalbinin attığı yerse;
türler de bu dünyanın iskeleti ve tamamlayanı.</p>
<p>Örs bize tür konusunda geniş bir kavram yelpazesi sunuyor.
Kalıplar, yalınlar, ortaklar, künyeler ve daha nicesi ama, fakat, ve lâkin;
Tüm diğer kavramlar bu yazıda ele alınacak tür kavramının süslenmiş;
yani hazır yapılandırılmış hali.</p>
<p>Türler özlerinde sıralıdır türler kümesidir. Kümesidir zira kendi kendisinin
üyesi olamaz. Kümesidir çünkü tanım tekrarı yapılamaz.
Sıralıdır çünkü tüm sistem dillerinde olduğu gibi üyelerin
sırası bit genişliğini ve bit sıralamasını belirler.</p>
<p>Örs dilinde türler nesne tabanlı dillerle benzeşmez.
C’deki ‘struct’ kavramının genişletilmiş halidir.
Tıpkı C dilindeki bir tür tanımladığınızda nesne dosyasında
nasıl yapılanacağı hayalinizde somutlaşıyorsa Örs’de de öyledir.
Bu yönüyle Örs’deki tür soyutlaması makineye yakındır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tür</span> <span class="n">Metin</span>
<span class="p">{</span>
  <span class="n">boyut</span>     <span class="n">t32</span><span class="p">;</span>
  <span class="n">hacim</span>     <span class="n">t32</span><span class="p">;</span>
  <span class="n">_harfler</span> <span class="o">*</span><span class="n">t8</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Her ne kadar Örs nesne tabanlı yazılım tarıznı desteklemese
ve de yapısalcılığı öne cıkarsa da Örs’de türlere işlem bağlamak mümkün.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">yukarıdaki</span> <span class="n">örneğin</span> <span class="n">devamı</span>
<span class="n">öz</span> <span class="o">*</span><span class="n">Metin</span>
<span class="n">iş</span> <span class="n">Yaz</span> <span class="n">Belge</span> <span class="o">*</span><span class="n">stdio</span><span class="p">::</span><span class="n">FILE</span>
<span class="p">{</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">fprintf</span><span class="p">(</span><span class="s2">&quot;metin: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">öz</span><span class="o">-&gt;</span><span class="n">Metin</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<span id="document-bolumler/tanıtım/turler/kalıp"></span><section id="kaliplar">
<h4>Kalıplar<a class="headerlink" href="#kaliplar" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Gerçek tür olmayan, yani sanal bir kavram olan kalıplar tür kavramındaki
tasarım eksiğini kapamayı amaçlar.</p>
<p>Mesela, C dilinde en basit yapı türlerinden olan zincirler için
her bir farklı türdeki zincir elemanı için yeniden tür tanımlamak zorunda kalıyoruz.</p>
<p>Dahası C++ ve Rust gibi dillerde elimizde var olan ve yapısı, boyutu, sıralaması
belirgin olan türler taçlandırılıyor ve türün boyutu ya da sıralaması değişebiliyor.
Bu konuda biz yazılımcıların bu dillerin tanıştırdığı harika özelliği suistimal etmemizin
de payı tabi ki yadsınamaz ama sistem yazılımcıları açımızdan çok ciddi bir
belirsizlik ve bir takım hata ayıklamalar samanlıkta iğne aramaya dönüşüyor.</p>
<p>Bu iki soruna karşılık Örs dili kalıp kavramını öne sürdü. Böylece,
‘kalıp’ kavramı vasat türler
kavram bütünlüğünü, yapısal katılığını korurken kalıplar aracılığıyla
hem tanım tekrarının
önüne geçebilmek hem de biz sistem yazılımcılarının haklı
takıntılarına çözüm üretmeyi amaçlıyor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kalıp</span> <span class="n">Dal</span> <span class="n">x</span>
<span class="p">{</span>
  <span class="n">Öz</span>       <span class="n">x</span><span class="p">;</span>
  <span class="n">Önceki</span>  <span class="o">*</span><span class="n">Dal</span><span class="s1">&#39;x;</span>
  <span class="n">Sonraki</span> <span class="o">*</span><span class="n">Dal</span><span class="s1">&#39;x;</span>
<span class="p">}</span>

<span class="n">kalıp</span> <span class="n">Zincir</span> <span class="n">x</span>
<span class="p">{</span>
  <span class="n">boyut</span> <span class="n">t32</span><span class="p">;</span>
  <span class="n">Baş</span> <span class="o">*</span><span class="n">Dal</span><span class="s1">&#39;x;</span>
  <span class="n">Son</span> <span class="o">*</span><span class="n">Dal</span><span class="s1">&#39;x;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıdaki örnek Örs’ün zincir kütüphanesinden alıntı. Basitçe anlaşılacağı üzere
kalıp ‘zincir’ ne olduğu bilinmeyen ‘x’ türü ile taçlandırılana kadar derleyici hafızasında
özel bir sanal tanım olarak yer alıyor. Genel yapısı belirgin olsa da boyutu belli olmadığı
için gerçek bir tür değil ve tamamen sanal.</p>
<p>Kalıplar herhangi değişken ya da değerin türünü belirlerken anlam kazanıyor.
Mesela yukarıdaki zinciri tam türüyle taçlandıralım.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iş</span> <span class="n">ZincirÖrneği</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">rakamlar</span> <span class="n">Zincir</span><span class="s1">&#39;tam;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Buyrun artık elimizde canlı, tam türüyle taçlandırılmış zincir türü var.</p>
<hr class="docutils" />
<section id="kalip-islemler">
<h5>Kalıp işlemler:<a class="headerlink" href="#kalip-islemler" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Nam-ı diğer sanal işlemler. Malûmunüz üzere kalıplar sanal olduğu için
onlara bağlanan işlemler de sanal olur. Yukarıdaki örneği devam ettirelim:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">öz</span> <span class="n">Zincir</span><span class="s1">&#39;x</span>
<span class="n">sanal</span> <span class="n">iş</span> <span class="n">Ekle</span> <span class="n">Veri</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
<span class="p">{</span>
  <span class="n">Dal</span> <span class="o">:=</span> <span class="n">temiz</span><span class="p">(</span><span class="o">%*</span><span class="n">öz</span><span class="o">.</span><span class="n">Baş</span><span class="p">);</span>
  <span class="n">Dal</span><span class="o">-&gt;</span><span class="n">Öz</span> <span class="o">=</span> <span class="n">Veri</span><span class="p">;</span>
  <span class="n">eğer</span> <span class="n">öz</span><span class="o">.</span><span class="n">boyut</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">Dal</span><span class="o">-&gt;</span><span class="n">Önceki</span>     <span class="o">=</span> <span class="n">öz</span><span class="o">.</span><span class="n">Son</span><span class="p">;</span>
    <span class="n">öz</span><span class="o">.</span><span class="n">Son</span><span class="o">-&gt;</span><span class="n">Sonraki</span> <span class="o">=</span> <span class="n">Dal</span><span class="p">;</span>
    <span class="n">öz</span><span class="o">.</span><span class="n">Son</span>          <span class="o">=</span> <span class="n">Dal</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">değilse</span>
  <span class="p">{</span>
    <span class="n">öz</span><span class="o">.</span><span class="n">Son</span> <span class="o">=</span> <span class="n">Dal</span><span class="p">;</span>
    <span class="n">öz</span><span class="o">.</span><span class="n">Baş</span> <span class="o">=</span> <span class="n">Dal</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">öz</span><span class="o">.</span><span class="n">boyut</span><span class="o">++</span><span class="p">;</span>
  <span class="n">dön</span> <span class="n">Dal</span><span class="o">-&gt;</span><span class="n">Öz</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">iş</span> <span class="n">ZincirÖrneği</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">rakamlar</span> <span class="n">Zincir</span><span class="s1">&#39;tam;</span>

  <span class="n">her</span> <span class="n">değer</span> <span class="n">i</span> <span class="n">tam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">rakamlar</span><span class="o">.</span><span class="n">Ekle</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="taclar-ve-donatimlar">
<h5>Taçlar ve Donatımlar:<a class="headerlink" href="#taclar-ve-donatimlar" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Aşağıda çok kullandığımız çizelge veri türü var.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kalıp</span> <span class="n">kök</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="p">{</span>
  <span class="n">Sıradaki</span> <span class="o">*</span><span class="n">kök</span><span class="s1">&#39;x,y;</span>
  <span class="nb">hash</span>      <span class="n">d32</span><span class="p">;</span>
  <span class="n">ad</span>        <span class="n">x</span><span class="p">;</span>
  <span class="n">öz</span>        <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">kalıp</span> <span class="n">k</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="p">{</span>
  <span class="n">boyut</span>      <span class="n">tam</span><span class="p">;</span>
  <span class="n">hacim</span>      <span class="n">doğal</span><span class="p">;</span>
  <span class="n">yığın</span>      <span class="n">dizi</span><span class="p">::</span><span class="n">k</span><span class="s1">&#39;*kök&#39;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
  <span class="n">Nesneler</span> <span class="o">**</span><span class="n">kök</span><span class="s1">&#39;x,y;</span>
<span class="p">}</span>

<span class="n">iş</span> <span class="n">DonatımÖrneği</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">sözlük</span> <span class="n">k</span><span class="s1">&#39;metin,tam;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bu örneğin içeriği değişebilir ve konumuz dışında ama
fark ettiğiniz üzere x ve y olası türleri sanki işlemlerdeki
değişken kavramı gibi davranıyor.
Göze öyle görünse de gerçekte tabi ki de kesinkes öyle değil.
Burada bu kavram çatışmasının önüne geçmek için kalıpların kabul ettiği olası tür simgelerini
‘taç’ olarak adlandırmayı ve kavramlandırmayı seçtik.</p>
<p>Herhangi bir kalıp ikiden fazla türle taçlandırılamaz ve o şekilde tanımlanamaz.
İkiden fazla tacın aslında gereksiz olduğu bir yana Örsün tasarım ilkeleriyle de tutarlıdır.
Yani Örs mantığına göre siz kalıp için ikiden fazla taç tanımlamışsanız sizin kalıbınızda bir
sorun vardır.</p>
<p>Mesela diyelim ki yukarıdaki ‘kök’ kalıbı 3 taç kabul ediyor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kalıp</span> <span class="n">kök</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="p">{</span>
  <span class="n">Sıradaki</span> <span class="o">*</span><span class="n">kök</span><span class="s1">&#39;x,y;</span>
  <span class="nb">hash</span>      <span class="n">z</span><span class="p">;</span>
  <span class="n">ad</span>        <span class="n">x</span><span class="p">;</span>
  <span class="n">öz</span>        <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bu örnekte bu kalıp belli ki çizelge algoritması tarafından kullanılacak ve ‘hash’ üyesinin
bit genişliği algoritma için önemli zira diyelim ki d64 türünde olsaydı farklı sabit ya da
algoritma kullanmanız gerebilirdi.
Evet değişken doğalı sözlük algoritmaları var ama
‘k’ veri türü o değişken doğalı algoritmayla uyum sağlayamaz. Yani ? Yani kalıp tanımında sorun var.</p>
<p>Örs’te kalıp da dahil tüm diğer kavramları olabildiğince doğrusal düşünmek istiyoruz.
İkili tacı sakın küçümsemeyin. O iki tacın içine yüz tane farklı iç içe geçmiş donatılmış tür
yerleştirebilirsiniz ama eğer veri türlerini bu şekilde saçaklandırma huyunuzun
Örs’ün kendi tasarım kaidelerini çiğneyip desteklemesini beklemeyiniz.</p>
<p>Donatım kavramı ise başlık altındaki misalde görüldüğü üzere kalıpların türe dönüştüğünde
aldığı olası türlere atıfta bulunuyor.
Malûm örnek için metin ve tam sayı sözlüğü değeri ‘k’ kalıbı ‘metin’ ve ‘tam’ türleri ile donatılmış.</p>
<p>Peki bu iki muğlak kavramı sanal işlemler için de kullanabilir miyiz ?
Buradaki uygulamasını kabul etmediğimiz takdirde, elbette. Farkı ise sanal
işlemlerde tıpkı işlemler gibi 16’dan fazla değişken almazlar
ve bu değişkenlerin muğlak türlerine hitaben ‘taç’;
türü belirlenmiş, yani çağrılmış, hallerine hitaben ‘donatım’ kavramlarını
bire bir olmamak şartıyla fevkâlade kullanabiliriz.</p>
</section>
</section>
<span id="document-bolumler/tanıtım/turler/yalın"></span><section id="yalin-tur-tanimlari">
<h4>Yalın tür tanımları<a class="headerlink" href="#yalin-tur-tanimlari" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Tekil gizli üyeleri olan türlerdir.</p>
<p>Bir yönüyle her hangi bir türü yeniden adlandırma
görevini üstlenirken; sıfatlarıyla güçlü bir kavrama evrilir.
————–
Basitçe:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tür</span> <span class="n">TamSayı</span> <span class="n">tam</span><span class="p">;</span>

<span class="n">sayı</span> <span class="n">TamSayı</span>
<span class="n">iş</span> <span class="n">Yazdır</span>
<span class="p">{</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;sayı: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sayı</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Görüldüğü üzere varsayılan yapıtaşı
‘tamsayı’ olarak tekrar tanımlanmış ve kendisine ait işlemler bağlanmış.
Bu yönüyle yalın türlerin görevi;
aynı veri türlerini kullanan ama tamamen farklı algoritmaları
kullanan yazılımlarda kavramları belirgin yapmak
ve yaygın türlere görevi olduğu ortamın amacına uygun görevler tanımlamaktır;</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tür</span> <span class="n">Sayılar</span> <span class="n">dizi</span><span class="p">::</span><span class="n">k</span><span class="s1">&#39;tam;</span>

<span class="n">sayılar</span> <span class="n">Sayılar</span>
<span class="n">iş</span> <span class="n">Yazdır</span>
<span class="p">{</span>
  <span class="n">her</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sayılar</span><span class="o">.</span><span class="n">boyut</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
      <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&#39;inci sayı = </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
      <span class="n">i</span><span class="p">,</span> <span class="n">sayılar</span><span class="o">.</span><span class="n">Öğe</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bir diğer önemli konu ise kalıpları donatırlar.
Kalıplara, tasarımları gereği,
gerçek işlemler bağlanamaz. Yalın türler
aracılığıyla donatıldıklarında kalıpların değer satırlıyla tekrar
tekrar tanımlanmasının önüne geçer ve
kalıpların anlam bulduğu ortamda
ilişkili işlemler ve algoritmalar bağlanabilir hale gelir.</p>
</section>
<span id="document-bolumler/tanıtım/turler/ortak"></span><section id="ortak">
<h4>Ortak<a class="headerlink" href="#ortak" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Tekil hafızanın çoğul değerler için kullanıldığı özel türlerdir.</p>
<p>Ortak olarak isimlendirilmesinin nedeni özlerinde konumlar beklemeleridir.
Zira yazılımda konumu ‘şey’ değerine saklar ve sonrasında bu konumun aslında
ne konumu olduğunu bilmeden tehlikeli sularda yüzerek işlemlerimizi yapabilirdik.
Ortak konumun farklı türler için ortak kullanılan bir konum olarak düşünüldüğünü
varsayarak bir çerçeve etrafında konumu yorumlar.
Bu bakımdan ‘şey’ türünün kavram olarak daraltılmış halidir.</p>
<p>C dilindeki ‘union’ kavramının Örs dilindeki dengidir.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ortak</span> <span class="n">çıktı</span>
<span class="p">{</span>
  <span class="n">sayı</span>      <span class="n">t64</span><span class="p">;</span>
  <span class="n">harfler</span>   <span class="n">t8</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">iş</span> <span class="n">Örnek</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">i</span> <span class="n">çıktı</span><span class="p">;</span>
  <span class="n">i</span><span class="o">.</span><span class="n">sayı</span> <span class="o">=</span> <span class="mh">0x0_41_42_43_44_45_46_47</span><span class="p">;</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
    <span class="s2">&quot;Konumlar:</span><span class="se">\n</span><span class="s2">&amp;i.sayı = %p</span><span class="se">\n</span><span class="s2">&amp;i.harfler</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;metni = &#39;</span><span class="si">%s</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">i</span><span class="o">.</span><span class="n">sayı</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">);</span>
    <span class="o">//</span><span class="n">benim</span> <span class="n">işlemcinin</span> <span class="n">mimarisinde</span> <span class="n">i</span><span class="o">.</span><span class="n">harfler</span> <span class="n">GFEDCBA</span> <span class="n">olarak</span> <span class="n">görünüyor</span>

  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
    <span class="s2">&quot;i          = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[0] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[1] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[2] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[3] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[4] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[5] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[6] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;harfler[7] = </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">i</span><span class="p">,</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
    <span class="n">i</span><span class="o">.</span><span class="n">harfler</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bu örneğin anlamsız olduğu düşünülebilir ki gerçekten de öyle.
Tek amacı sayı ve harfler adlı üyelerin aynı konumu paylaştığını göstermek
ama zaten ortakların yaygın kullanımı da bu şekilde olmaz.
Genelde künyelendirilerek kullanılırlar. Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ortak</span> <span class="n">çıktı</span>
<span class="p">{</span>
  <span class="n">sayı</span>      <span class="n">t64</span><span class="p">;</span>
  <span class="n">harfler</span>  <span class="o">*</span><span class="n">t8</span><span class="p">;</span>
  <span class="n">url</span>      <span class="o">*</span><span class="n">t8</span><span class="p">;</span>
  <span class="n">Metin</span>    <span class="o">*</span><span class="n">metin</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">sayaç</span> <span class="n">seçimler</span>
<span class="p">{</span>
  <span class="n">Sayı</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">Harfler</span><span class="p">;</span>
  <span class="n">Url</span><span class="p">;</span>
  <span class="n">Metin</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">tür</span> <span class="n">imge</span>
<span class="p">{</span>
  <span class="n">künye</span>  <span class="n">t32</span><span class="p">;</span>
  <span class="n">içerik</span> <span class="n">çıktı</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Veri iskeletinden de anlaşılacağı üzere basitçe metin çözümleme türü tanımlanmış.
Bu iskeleti derleyicilerden, dil sunucularına, veri tabanlarından, oyunlara her yerde kullanacaksınız.
En az zincirler konusu kadar yaygın bir iskelet.</p>
</section>
</div>
<p>Buraya kadar işlemler ve işlevlerle ilgilendik
ama tüm bunlar anlamlı yapılandırılmış veri olmadan tamamen anlamsız
kalıyor.</p>
<p>Bu bölümde Örs dilinin türlere yaklaşımını ele alacağız.</p>
<hr class="docutils" />
<div class="graphviz"><img src="_images/graphviz-e10ccf6f497866c3858664393fdf8d55220c0617.png" alt="graph D {
subgraph cluster_0 {
   label=&quot;Türler&quot;;
   türler [label=&quot;tür&quot; fixedsize=true fillcolor=red style=filled shape=circle,width=3];
   subgraph cluster_1
   {
     label=&quot;Gerçek Türler&quot;
     yapıtaşları [label=&quot;yapıtaşları&quot; fixedsize=true shape=circle,width=3];
     ortak [label=&quot;ortak&quot;];

     yalın [label=&quot;yalın&quot;];
   }
   subgraph cluster_2
   {
     label=&quot;yapıtaşları&quot;;
     subgraph cluster_3
     {
        label=&quot;konum&quot;;
        iş  [label=&quot;işlemler&quot;];
        şey [label=&quot;şey&quot;];
        mimari -- şey;
     }
     subgraph cluster_4
     {
        label=&quot;sayılar&quot;;
        mimari  [label=&quot;mimari&quot;];
        subgraph cluster_5
        {
           label=&quot;tam sayılar&quot;;
           t8   [label = &quot;t8&quot;];
           t16  [label = &quot;t16&quot;];
           t32  [label = &quot;t32&quot;];
           t64  [label = &quot;t64&quot;];
           t128 [label = &quot;t128&quot;];
           tam  [label = &quot;tam&quot;];
           t8  -- t16;
           t16 -- t32;
           t32 -- t64;
           t64 -- t128;
           t32 -- tam;
        }
        subgraph cluster_6
        {
           label=&quot;doğal sayılar&quot;;
           d8    [label = &quot;d8&quot;];
           d16   [label = &quot;d16&quot;];
           d32   [label = &quot;d32&quot;];
           d64   [label = &quot;d64&quot;];
           d128  [label = &quot;d128&quot;];
           doğal [label = &quot;doğal&quot;];
           d8  -- d16;
           d16 -- d32;
           d32 -- d64;
           d64 -- d128;
           d32 -- doğal;
        }
        subgraph cluster_7
        {
           label=&quot;ondalık sayılar&quot;;
           o32     [label = &quot;o32&quot;];
           o64     [label = &quot;o64&quot;];
           o128    [label = &quot;o128&quot;];
           ondalık [label = &quot;ondalık&quot;];
           o32 -- o64;
           o64 -- o128;
           o64 -- ondalık;
        }
     }
     ondalık -- yapıtaşları;
     doğal   -- yapıtaşları;
     tam     -- yapıtaşları;
     şey     -- yapıtaşları;
   }
   subgraph cluster_8
   {
     label=&quot;sanal türler&quot;;
     sayaç [label=&quot;sayaç&quot;];
     kalıp [label=&quot;kalıp&quot;];
     tam         -- sayaç;
   }
    iş  -- türler;
    türler -- ortak;
    türler -- yapıtaşları;
    türler -- kalıp;
    türler -- yalın;
    sayaç       -- türler;
  }
}" class="graphviz" /></div>
</section>
<span id="document-bolumler/tanıtım/birimler"></span><section id="birimler">
<h3>Birimler<a class="headerlink" href="#birimler" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<p>Örs dilinde çözümlenen söz dizisinin ilk ürünü olarak kabaca tanımlanabilir.</p>
<div class="admonition warning">
<p class="admonition-title">Uyarı</p>
<p>Örs’teki birim özelliğini lütfen, sakın ki sakın
nesne tabanlı dillerdeki özelliklerle karıştırmayınız.</p>
</div>
<p>Kabaca diyorum çünkü bu konu göründüğünden daha derin.
C’de her bir ‘.c’ belgesi genelde ‘.o’ belgesine çevrilir.</p>
<div class="admonition note">
<p class="admonition-title">Not</p>
<p>Yazının devamında;</p>
<div class="line-block">
<div class="line">‘.o’ uzantılı belgeye <strong>nesne</strong> belgesi,</div>
<div class="line">‘.a’ uzantılı belgeye <strong>dahili</strong> kütüphane,</div>
<div class="line">‘.so’ uzantılı belgeye ise <strong>harici</strong> kütüphane</div>
</div>
<p>diye atıfta bulunacağız.</p>
</div>
<p>Nesne belgelerinin içeriğinde basitçe makina koduna yorumlanmış
işlemleriniz ve yazılımınızın hafıza iskeleti bulunur.
Durağan değerlerin hafızada nasıl canlanacağı bilgisi bu belgededir.
İşlemler ise yalındır. Yani dahili ve harici kütüphanelerle
nasıl iletişime geçeceği bilgisini bulundurmaz.</p>
<p>Eğer diğer kütüphanelerle sade yöntem olan işlem çağrıları ile
iletişim kursaydık ve bu işlem çağrılarının küresel değişken
değerler kullanmadığını varsaysaydık bu konu tüm dillerde
basmakalıp ele alınırdı ama ne güzel ki gerçek öyle değil.</p>
<p>Nesne belgeleri yazdırılıp üretim süreci tamamlanınca isteğe göre bağlama süreci başlar.
İsteğe bağlı diyorum çünkü ürünler illa ki bağlanmak zorunda değil. Çünkü bağlama
sürecinin yazılım dilleri ile alakası bile tartışılabilir. Yaygın kullanım isimleriyle
‘.a’ ve ‘.so’ uzantılı belgelerinin biri dahili bağlanmışken diğerinde sadece harici atıflara
nasıl canlı ya da yazılım hafızaya alınırken bağlanacağı bilgisi vardır.
Sistem dilleri genelde bu sorunun işletim sistemine ait olduğu varsayımı ile hareket ederler ki
pek çok zaman sistem dillerini derletmek içim ‘cmake’ gibi yazılımları
kullanmamızın ana nedenlerinden biridir. Bir takım kütüphanelere atıfta bulunacağız ama
bu belgelerin nerede olduğunu bilmiyoruz sorununa çözüm üretirler.</p>
<p>Diğer taraftan örs dili türlerinin neden değişken türlü
işlemler tanımlamamasının kökünde yatan nedenlerden birisi de budur.
Örste değişken türlü sanal işlemler tanımlayabiliyorken; değişken türlü işlemler
tanımlanamıyor. Şimdi bunun her bir tür başlatılıp işlem çağrıldığında yeniden işlemin
derlenmesi sorunu bir tarafa aynı zamanda bağlama sürecinde de sıkıntı yaşatıyor.
Burada bu özelliğe sahip diller iyi ya da kötü dillerdir diye bir argüman savunmuyoruz.
Bu bambaşka bir tartışma konusu. Birimlerle alakası bu işlemlerin nasıl bağlanacağı ve
konumlarının nasıl belirleneceğidir. Örnek vermem gerikirse;
diyelim ki C++ mantığında derleme yapan bir dil ile;
bir yerde ‘dizi&lt;tam&gt;’ türünde,
başka bir yerde ise ‘dizi&lt;hesaplar&gt;’ diye iki farklı tür tanımladınız.
Eğer kalıp taçları konum olsaydı neyin konumu olmaksızın tür aynı olacaktı ama değil.
Peki yorumlanan türleri aynı olmayan dizi kalıbının işlemleri ne olacaktı ?
Tüm bu işlemleri ya her çağrıldıklarında yeniden derleyecektiniz ya da değeri birinci dereceden
konummuş gibi hayal edip yığın çizelgesi oluşturacaktınız.
Üçüncü çözümde ise hiç derlemeyip sanal işlemmiş gibi ele alacaktınız ama o kavram zaten
Örs için tanımlı ve geriye elinizde 2 çözüm kalıyor.
Peki bu işlem atfı yığın çizelgesini nasıl bağlattıracaktınız ?
C++ dilinin namının şaibeli olmasının temel nedenlerinden bir tanesi bu çok ciddi sorun bu arada.
Bu ciddi soruna ‘Sanal İşlemler’ konusunda tekrar değineceğiz.
Birimlerin nasıl ele alındığı
ve nasıl algılanması gerektiği ile derinden alakalı temel bir sorun olduğu için
hatırlatma ihtiyacı duyduk.</p>
<p>Birim kavramının amaçlarından bir diğeri ise
isim çakışmasını ve dolaşmasını engellemektir.
Mesela elinizde ekleme yapan birden fazla birim olduğunu düşünün.
Farzedelim ki bunlardan biri ‘dizi’ diğeri ‘çizelge’ birimi olsun.
Bu iki birimde doğal algoritmalarının bir parçası olarak ‘ekle’ işlemi tanımlayacaktı.
Eğer Örs bu iki birimi tek birim olarak ele alsaydı;
bu işlemlerin isimleri çakıştığı için hata vermek zorunda kalacaktı.
Birim kavramı işlevde bu dolaşmanın da önüne geçer.</p>
<p>Altı çizilmesi gereken bir diğer konu Örs’teki
birimler kavramı kesinlikle nesne tabanlı dillerle karşılaştırılmamalıdır.
Örste birimden kasıt ‘CU’ yani üretim süreci kavramı olan ‘compilation unit’
diye ingilizce tabir edilen kavrama ve bu kavramın üretilmiş haline,
yani ‘.o’ belgeleri ve alâkalı türevlerine atıfta bulunur.
Bizim istediğimiz şey basitçe; bu ürünlerin nasıl bir araya getirilip kütüphanelere
dönüşeceğinin belirgin olmasıdır. Bu mânada birim kavramının amacı derlemenin
tarama, çözümleme, üretim ve bağlama süreçlerinin olabildiğince örtüşmesi ve
bu yazılımlar hayata geçtiğinde birbirleri ile iletişim kurarken tasarlanma sürecindeki
kavram kümesi ile ortak kavram alanında kesişmesidir.
Zira sistem dilleri için yukarıda
özetle anlatıldığı gibi nesne belgelerinin üretiminden sonra yazılımınız özünde bir
soyutlama olan yazılım dilinden epey ayrışıp;
gerçek hayattaki görev ve ilişkileri ile örtüşmeye başlamaktadır.
Kavramların olabildiğince örtüşük olmasını
istiyoruz ki on binlerce kütüphanenin birbirine dolanırcasına bağlandığı ve
tüm bu süreci denetlemek için ayrı yazılımların kullanıldığı cengâmelere saplanma olasılığımızı
düşürebilelim.</p>
<p>Çünkü hoşumuza gitse de gitmese de üretilen
birimler birbirleri ile ilişkilerine göre dallanıp,
derecelenmeye ve ağaçlanmaya başlıyor.</p>
<p>Daha ilginç olanı ise kaynağınızda dosya yaratmışsınız ve bu dosya genelde yukarıda
bahsettiğimiz ilişki ağacının bir parçası oluyor ama pek çok yazılım dili bu dosyaları
birim olarak kabul etmiyor.</p>
<p>Birimler tüm bu yukarıdaki bahsettiğimiz dallanma sorununu, derecelenmeyi,
yazılım dili seviyesinde çözmeye yarayan, içeriğinde derlenebilir öğeleri küme olarak tutan
ve izdüşümü nesne belgeleri olan kavramlardandır. Bazı dillerden farkı
sizin kaynak kodu ağacınızla örtüşük olmasıdır.</p>
<div class="admonition warning">
<p class="admonition-title">Uyarı</p>
<p>Tekrar uyarmak gerekiyor. Aşağıdaki örnek basitliği için seçilmiştir. Lütfen
birim özelliğininin nesne tabanlı tarzla ne bire bir örtüştüğünü ne de
öyle bir gayesi olduğunu biliniz.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dahili</span> <span class="n">merkez</span><span class="p">::</span><span class="n">c</span><span class="p">::</span><span class="n">stdio</span><span class="p">;</span>

<span class="n">birim</span> <span class="n">işlemler</span>
<span class="p">{</span>
  <span class="n">birim</span> <span class="n">katlı</span>
  <span class="p">{</span>
    <span class="n">iş</span> <span class="n">Çarp</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">:</span> <span class="n">tam</span> <span class="o">=&gt;</span>
      <span class="n">dön</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">:</span> <span class="n">tam</span> <span class="o">=&gt;</span> <span class="n">dön</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">iş</span> <span class="n">Topla</span> <span class="n">a</span> <span class="n">tam</span><span class="p">,</span> <span class="n">b</span> <span class="n">tam</span><span class="p">:</span> <span class="n">tam</span> <span class="o">=&gt;</span> <span class="n">dön</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">iş</span> <span class="n">SonuçYaz</span><span class="p">:</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span>
    <span class="s2">&quot;işlemler::Topla       = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;işlemler::katlı::Çarp = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">,</span>
    <span class="n">işlemler</span><span class="p">::</span><span class="n">Topla</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span>
    <span class="n">işlemler</span><span class="p">::</span><span class="n">katlı</span><span class="p">::</span><span class="n">Çarp</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yapılan şey şu örnekte diğer dillerden farklı değil.
İşlemi tanımladık ve giriş işleminden çağırdık.
Fark edeceğiniz üzere tanımlı birimlerden işlem çağırabilmek için birimin içeriklerine erişmek
gerikiyor ve bunu ‘::’ simgesini kullanarak yapabiliyoruz.</p>
<p>‘SonuçYaz’ işlemi fark ettiğiniz üzere anlamlandırdığınız ağaçta en üst seviyede.
Bu bağlamda elimizde üretilmesi gereken 3 farklı birim var. Bağlama sürecinde
çalıştırma belgesi, dahili veya harici kütüphene üretilecek olduğunda
yapılacak olan şey basitçe ‘işlemler::katlı’ birimi işlemlere eklenecek ve bağlanacak;
‘işlemler’ birimi de üst birime eklenecek ve toplanacak.</p>
<p>Bir diğer örnek varsayılım ki elimizde aşağıdaki gibi
her bir işlemin ayrı belgede ele alındığı; gayet yaygın olan bir kaynak ağacı var:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>birim_örneği
├── işlem
|   ├── katlı
|   |   └── çarpma.ors
|   ├── çıkarma.ors
|   └── toplama.ors
└── sonuç_yaz.ors
</pre></div>
</div>
<p>Bu dosya ağacının oluşturacağı birim ağacı ile bir üst örnekte
oluşacak olan birim ağaçları bire bir aynı.
Tek fark kaynak kodunuzu düzenleme tercihiniz ki o size kalmış.
Ama Örs derleyicisi eğer dosya açıp içine kaynak kodu koymuşsanız bunu birim olarak kabul eder
ve yukarıdaki bağlama sürecine tabi tutar.</p>
<p>Tam burada birimlerin nasıl ele alındığı iyice belirginleşmeye başladı.</p>
<p><strong>Peki ya Örs dili dahili veya harici kütüphaneleri nasıl görüyor ve ele alıyor ?</strong></p>
<p>Yukarıdaki kaynak ağacını tekrar ele alalım.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>birim_örneği
├── özelleştirme.uzn
├── işlem
|   ├── katlı
|   |   └── çarpma.ors
|   ├── çıkarma.ors
|   └── toplama.ors
└── sonuç_yaz.ors
</pre></div>
</div>
<p>Sadece aşağıdaki uzengi satırını dosya kökündeki;
‘özelleştirme.uzn’ belgesine yazmak yeterli olacaktır.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">özelleştirme</span><span class="p">:</span>
  <span class="n">ad</span><span class="p">:</span> <span class="s2">&quot;birim_örneği&quot;</span><span class="p">,</span>
  <span class="n">çıktı</span><span class="p">:</span> <span class="n">birim_örneği</span><span class="p">,</span>
  <span class="n">ürün_türü</span><span class="p">:</span> <span class="n">çalıştırma</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Hatırlatma</span><span class="p">:</span>
<span class="n">Ürün</span> <span class="n">türünü</span> <span class="n">belirlemek</span> <span class="n">için</span><span class="p">;</span>
<span class="s1">&#39;nesne&#39;</span>      <span class="p">:</span> <span class="n">yalın</span> <span class="n">nesne</span> <span class="n">belgesi</span><span class="p">,</span>
<span class="s1">&#39;çalıştırma&#39;</span> <span class="p">:</span> <span class="n">çalıştırılabilir</span> <span class="n">tetik</span> <span class="n">belgesini</span><span class="p">,</span>
<span class="s1">&#39;makina&#39;</span>     <span class="p">:</span> <span class="n">makina</span> <span class="n">dili</span><span class="p">,</span>
<span class="s1">&#39;dahili&#39;</span>     <span class="p">:</span> <span class="n">dahili</span> <span class="n">kütüphane</span><span class="p">,</span>
<span class="s1">&#39;harici&#39;</span>     <span class="p">:</span> <span class="n">harici</span> <span class="n">kütüphane</span>
<span class="n">seçenekleri</span><span class="p">;</span> <span class="n">ilgili</span> <span class="n">çıktıları</span> <span class="n">üretir</span><span class="o">.</span>
</pre></div>
</div>
</section>
<span id="document-bolumler/tanıtım/yine_yeniden_islemler"></span><section id="yine-yeniden-islemler">
<h3>Yine Yeniden İşlemler:<a class="headerlink" href="#yine-yeniden-islemler" title="Bu başlık için kalıcı bağlantı">#</a></h3>
<p>Tür ve birimler konusunu ele aldığımıza göre işlemleri irdelemeye devam edebiliriz.</p>
<p>C dilinde en çok yaşanan sıkıntılardan birisi, önce türü tanımlayıp sonrasında
o türle ilişkili işlemler tanımlanırken özellikle isimlendirme ve türün kendisini
tekrar tekrar tanımlama konusunda yaşanan köle işidir.</p>
<div class="admonition note">
<p class="admonition-title">Not</p>
<p>C’de bu tarz kıymıkların olmasının nedenlerinden birisi o dönemdeki
bilgisayarların kaynak yetersizliğinden ileri gelir. Mesela C’de
bolca ‘strlen, fcntl’ vb bir takım okunması, ezbenlenmesi anlanması
bile zor olan işlemler ve kütüphaneler var ve bunların amacı
sözlük algoritmasının işini kolaylaştırmaktan öte değil.</p>
<p>Yani özet olarak C’yi eleştirirken biraz dönemin koşullarını da
göz önününde bulundurmak gerekiyor.</p>
</div>
<p>Mesela dediniz ki:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">dizi</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">hacim</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">boyut</span><span class="p">;</span>
  <span class="nb">int</span><span class="o">*</span> <span class="n">Icerik</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bu türe işlemler tanımlayacaksınız ama gördüğünüz gibi bu işlemler sadece
<strong>‘int*’</strong> dizisi için düzgün çalışacak ve bu da yetmezmiş gibi aşağıdaki gibi
çirkinlikleri gözden çıkaracaksınız.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">kütüphaneAdı_dizi_Topla</span><span class="p">(</span><span class="n">dizi</span><span class="o">*</span> <span class="n">Dizi</span><span class="p">,</span> <span class="nb">int</span> <span class="n">toplanacakSayı</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">boyut</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">Icerik</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">toplanacakSayı</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Şimdi beden kısmını boşverelim:
İsim aslında içinde doğrusal bir ağaçlandırma yapıyor.
‘kütüphaneAdı’ +
‘işlemi anlam kümesine alan türün adı’ + ‘işlemin görevinin adı’ gibi bir kalıba
uyuyor. C’deki bu eksiklik çeşitli doğrusal kalıplarla aşılabilir.
Daha ciddi sorun hem bu isim kalıplarının hem de onların bedenlerinin
farklı yapıtaşları ve türler için tekrar edebiliyor olması.</p>
<p>Mesela yukarıdaki diziyi, tam sayı dizisi değil de ondalık dizisi olarak yazsaydık
ve bunların her bir elemanını bir ondalık ile toplayacak olsaydık yine aynı şeyleri tekrar edecektik.</p>
<p>C’de bu sorunu öngeçişler ile fevkalede aşabiliriz
ama bu sefer de derleyiciye türü tekrar tekar tanımlayacaktık. Dahası her bir öngeçiş işlemi çağrısı
bizim kütüphanemizin boyutunu daha da şişirecekti ki bazen çok basit yazılımlar için ağaçlanan öngeçişler
ürünü devasâ boyutlara ulaştırtabiliyor.</p>
<p>Diğer taraftan bu konuyu çözmüş yazılım dilleri yok mu ? Tabi ki de var. Özellikle nesne
tabanlı yazılım tarzının geliştirilme nedenlerinden bir tanesi bu yukarıda irdelediğimiz sorun ama
sistem dillerinde nesne tabanlı tarz aşılması zor yapısal sorunlara yol açıyor ve daha içinden çıkılamazı
hata ayıklamayı zorlaştırıyor. Bunlar yetmezmiş gibi işlemlerin cağrı yöntemini değiştire de biliyorlar;
ki sistem sürücüleri ile iletişime geçerken yeniden köprüler yazmanız, yazılımınızla
sürücü arasında haberleşme sağlayacak arayüz geliştirmeniz gerekiyor.
Nerede kaldı şimdi tasarım yapmanın keyfi ? Nerede bizim işimizi kolaylaştıran araçlar ? Yani her bir özelliği
kullandığımda başımı nerede ağrıtacak öngöremiyorsam o özelliği kullanmanın ne anlamı var ?
Bu bir kabus.</p>
<p>Konu göründüğünden derin olduğu için Örs’ün bu konuda tüm dertlere devâ büyülü çözümler bulduğunu ileri sürmek
hayalperestlik olur ama C iletişimini zorlaştırmadan, çağrı yöntemini değiştirmeden, türleri yozlaştırmadan da
yukarıdaki sorunları ele almak mümkün.</p>
<p>Şimdi konuyu derinleştirebiliriz:</p>
<section id="tur-islemleri">
<h4>Tür İşlemleri:<a class="headerlink" href="#tur-islemleri" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Yukarıdaki örnekte gösterildiği gibi tanımlı türlerin anlam kümelerinde yer alan işlemlerdir.
C işlem çağrıları ile tam tutarlılığı vardır ve bu kaideyi bozmamak adına ilk değişkenleri pek çok yazılım
dilinde olduğu gibi türün kendisidir. Mesela yukarıdaki C örneğini Örs’e çevirelim:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tür</span> <span class="n">dizi</span>
<span class="p">{</span>
  <span class="n">hacim</span>   <span class="n">tam</span><span class="p">;</span>
  <span class="n">boyut</span>   <span class="n">tam</span><span class="p">;</span>
  <span class="n">İçerik</span> <span class="o">*</span><span class="n">tam</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dizi</span> <span class="n">dizi</span>
<span class="n">iş</span> <span class="n">Yenile</span> <span class="n">hacim</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">boyut</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">hacim</span>  <span class="o">=</span> <span class="n">hacim</span><span class="p">;</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">İçerik</span> <span class="o">=</span> <span class="n">temiz</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="n">boyut</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">Dizi</span> <span class="o">*</span><span class="n">dizi</span>
<span class="n">iş</span> <span class="n">Topla</span> <span class="n">toplanacakSayı</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">her</span> <span class="n">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">boyut</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">İçerik</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">toplanacakSayı</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">çağrı</span> <span class="n">örneği</span><span class="p">:</span>
<span class="n">iş</span> <span class="n">Giriş</span> <span class="n">argümanSayısı</span> <span class="n">tam</span><span class="p">,</span> <span class="n">_argümanlar</span> <span class="o">**</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">tamDizisi</span> <span class="n">dizi</span><span class="p">;</span>
  <span class="n">dizi</span><span class="o">.</span><span class="n">Yenile</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">dizi</span><span class="p">)</span><span class="o">.</span><span class="n">Topla</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Baş kısmınında tanımlanan ilk değişken türün kendisi oluyor. Bu söz dizimi tanımlı işlemi türe bağlıyor.
Fark edeceğiniz üzere türün derecesi var. Evet Örs dilinde tanımlı tür işlemlerinde ilk değişkenin tür kısmı
önemli. Burada işlem bizden tanımlı türle yapılandırılmış 2 dereceli değer istiyorsa buna riayet edilmeli çünkü
her ne kadar ilk değişken türe bağlıyor olsa da onun dışındaki davranışları herhangi bir diğer değişken ile <strong>aynı</strong>.</p>
<hr class="docutils" />
<p>Nasıl türlere işlem bağlayabiliyorsak yalın türlere de aynı şekilde işlem bağlamak mümkün.</p>
</section>
<section id="sanal-islemler">
<h4>Sanal İşlemler:<a class="headerlink" href="#sanal-islemler" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Canlı işlem çağrısı yapmayan, türü illa ki belirli olmayan ve üretileceği zaman türü anlamlandırılan işlemlerdir.
C’deki işlevsel dengi öngeçiş işlemleridir denilebilir ama özlerinde farklıdırlar. Öngeçiş işlemleri çözümleme
sürecinde anlamlandırılmışken sanal işlemler üretim sürecine kadar anlamlı değillerdir. Sanal çağrılarının
yapıldığı satıra gelince türleri belirlenir ve çağrıldığı yere yamanırlar.</p>
<p>İşlem çağırıları sanal olduğu için doğalarında hızlılardır ama derleme ürününün boyutunu artırırlar.
Kullanım amaçlarından en önemlisi tekrar eden girdi çıktı işlemleridir. Bu işlemler özlerinde aynı şeyler olduklarından
bunları mümkün olduğunca hızlı ve türlerini önemsemeden çağırmak isteriz. Bu örnek bir kaide olmamakla birlikte
sanal işlemlerin uygulamadaki tasarım nedenlerinden bir tanesidir.</p>
</section>
<section id="sanal-tur-islemleri">
<h4>Sanal Tür İşlemleri:<a class="headerlink" href="#sanal-tur-islemleri" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Türlerle ilişkili bazı işler var ki bunların gerçek işlem olmasının anlamı bile yok. Mesela türlerin başlatılması,
yenilenmesi, temizlenmesi gibi türler arası tekrar eden işlemler için canlı işlem çağrısı yapmayan,
ilk türü hariç diğer türleri illa ki belirli olmayan ve üretileceği zaman anlamlandırılan işlemlere bu özel durumda ihtiyaç vardır.
Mesela yukarıdaki örneği yeniden ele alalım:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tür</span> <span class="n">dizi</span>
<span class="p">{</span>
  <span class="n">hacim</span>   <span class="n">tam</span><span class="p">;</span>
  <span class="n">boyut</span>   <span class="n">tam</span><span class="p">;</span>
  <span class="n">İçerik</span> <span class="o">*</span><span class="n">tam</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dizi</span> <span class="n">dizi</span>
<span class="n">sanal</span> <span class="n">iş</span>
<span class="n">Yapılandır</span> <span class="n">hacim</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">boyut</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">hacim</span>  <span class="o">=</span> <span class="n">hacim</span><span class="p">;</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">İçerik</span> <span class="o">=</span> <span class="n">temiz</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="n">hacim</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">Dizi</span> <span class="o">*</span><span class="n">dizi</span>
<span class="n">iş</span> <span class="n">Topla</span> <span class="n">toplanacakSayı</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">her</span> <span class="n">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">boyut</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">İçerik</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">toplanacakSayı</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">çağrı</span> <span class="n">örneği</span><span class="p">:</span>
<span class="n">iş</span> <span class="n">Giriş</span> <span class="n">argümanSayısı</span> <span class="n">tam</span><span class="p">,</span> <span class="n">_argümanlar</span> <span class="o">**</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">tamDizisi</span> <span class="n">dizi</span><span class="p">;</span>
  <span class="n">dizi</span><span class="o">.</span><span class="n">Yenile</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">tamDizisi</span><span class="p">)</span><span class="o">.</span><span class="n">Topla</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Burada <strong>‘Yapılandır’</strong> işlemini sanal yaptık zira bu iş türü tekrar yapılandırmaktan başka bir görevi üstlenmiyor.
Eğer ki sanal iş tanımlama özelliği olmasaydı <strong>‘Giriş’</strong> işleminde değeri oluşturduktan, fark ederseniz başlatma
fiilini kullanmadım, sonraki satırlarda oluşturulan değeri yapılandıracaktı.
Sanal türlerin yerinde kullanımına daha iyi örnek olamaz. Zira hızın bir önemi yok çünkü oluşturulan değeri zaten yapılandıracağız,
ürün boyutundaki artışın bir önemi yok yapılandırmak zorunada olduğumuz için türün boyutu artacak.
Özet olarak hız ve hafıza arasındaki
ters orantı tahteravallisine binmeden bu sorunu okunabilir bir şekilde hallettik ki sanal türlerin uygulamadaki tasarım amaçlarından
en önemlisi budur. Mesela şunu da yapabilir miydik ?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span><span class="n">yukarıdaki</span> <span class="n">örneği</span> <span class="n">tekrar</span> <span class="n">ele</span> <span class="n">alalım</span><span class="o">*/</span>
<span class="o">...</span>
<span class="n">sanal</span> <span class="n">iş</span>
<span class="n">Dizi</span> <span class="n">hacim</span> <span class="n">tam</span> <span class="p">:</span> <span class="n">dönüş</span> <span class="n">dizi</span>
<span class="p">{</span>
  <span class="n">dönüş</span><span class="o">.</span><span class="n">boyut</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">dönüş</span><span class="o">.</span><span class="n">hacim</span>  <span class="o">=</span> <span class="n">hacim</span><span class="p">;</span>
  <span class="n">dönüş</span><span class="o">.</span><span class="n">İçerik</span> <span class="o">=</span> <span class="n">temiz</span><span class="p">(</span><span class="n">tam</span><span class="p">[</span><span class="n">hacim</span><span class="p">]);</span>
<span class="p">}</span>
<span class="o">...</span>
<span class="n">iş</span> <span class="n">Giriş</span> <span class="n">argümanSayısı</span> <span class="n">tam</span><span class="p">,</span> <span class="n">_argümanlar</span> <span class="o">**</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="n">tamDizisi</span> <span class="o">:=</span> <span class="n">Dizi</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">tamDizisi</span><span class="p">)</span><span class="o">.</span><span class="n">Topla</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bu örnekte tanımlı <strong>‘Dizi’</strong> işi sanal ama türe bağlı değil ve
bize yapılandırılmış birinci dereceden dizi değeri dönüyor.
Tahteravallide değiliz, temiz ve okunabilir kod.</p>
</section>
<section id="yalin-tur-sanal-islemleri">
<h4>Yalın Tür Sanal İşlemleri:<a class="headerlink" href="#yalin-tur-sanal-islemleri" title="Bu başlık için kalıcı bağlantı">#</a></h4>
<p>Yalın türlerin amaçlarından en önemlisi onlara tür bağlayabilmektir. En basitinden
posix kütüphanesindeki işlemlerin çoğu <strong>‘int’</strong>, Örs dengi <strong>‘tam’</strong>, yapıtaşıyla işlem yapar
ama bu yapıtaşlarının kendi görev alanlarında anlam kümeleri vardır.
Bazen bu tam sayı hata anlamı taşırken,
bazen açılan belge anlamını ve başka başka anlamları taşır.</p>
<p>Yalın türlerde sanal işlemler ile tüm bu anlam kargaşasının önüne geçebilir ve aynı yapıtaşlarının
kullandığı gibi görünen ama özlerinde farklı olan işler tasarlayıp kavramlar arası çizgiyi belirginleştirebiliriz.
Bu kavram sınırları önemli mesela elinizde <strong>‘rgba’</strong> renk türü vardır ve bu tür aynı anda hem
resimlerde, hem oyunlarda farklı kavram alanlarında kullanılabilir. Tür aynı ama görevleri farklı.</p>
<p>Mesela:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tür</span> <span class="n">belge</span> <span class="n">tam</span><span class="p">;</span>

<span class="n">öz</span> <span class="n">belge</span>
<span class="n">sanal</span> <span class="n">iş</span>
<span class="n">Aç</span> <span class="n">_konum</span> <span class="o">*</span><span class="n">t8</span><span class="p">,</span> <span class="n">izinler</span> <span class="n">tam</span><span class="p">,</span> <span class="n">mod</span> <span class="n">tam</span> <span class="p">:</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">öz</span> <span class="o">=</span> <span class="n">sys</span><span class="p">::</span><span class="nb">open</span><span class="p">(</span><span class="n">_konum</span><span class="p">,</span>
    <span class="n">izinler</span><span class="p">,</span>
    <span class="n">mod</span><span class="p">);</span>
  <span class="n">eğer</span> <span class="n">öz</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">durum</span> <span class="n">error</span><span class="p">::</span><span class="n">no</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">seçim</span> <span class="n">error</span><span class="p">::</span><span class="n">code</span><span class="p">::</span><span class="n">Access</span><span class="p">:</span>
        <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Erişim hatası</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
      <span class="n">varsayılan</span><span class="p">:</span>
        <span class="n">stdio</span><span class="p">::</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;bilinmeyen hata : </span><span class="si">%d</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">öz</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">dön</span> <span class="n">öz</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Yukarıda meşhur <strong>‘open’</strong> işleminin döneceği <strong>‘tam’</strong>
türü belge olarak yalın halde tanımlanmış ve kavram alanında olası hatayı ele alan yeni bir işlem tasarlanmış.
Bu görevi belge türündeki değerin oluşturulduğu yerde de yerine getirebilirdik ama burada aynı tür için olası
tekrar eden sıralı satırlar kümesi var. Bir diğer deyişle sanal işlem kullanımı için mükemmel bir örnek.</p>
<hr class="docutils" />
<section id="kalip-sanal-islemler">
<h5>Kalıp Sanal işlemler:<a class="headerlink" href="#kalip-sanal-islemler" title="Bu başlık için kalıcı bağlantı">#</a></h5>
<p>Nasıl gerçek olmayan, özlerinde sanal türler olan kalıplar var ise bunlara bağlanabilecek sanal işler de vardır.
Kalıpların türü belirgin olmadığı için işlem tanımlayamayız ama zaten kalıplar uygulamadaki güçlerini buradan alıyor.</p>
<p>Yukarıdaki örnekte eğer ki <strong>‘tam’</strong> dizisi değil de ondalık dizi ya da istenilen türde bir dizi tanımlayıp
işlemleri kullanmak isteseydik bunu yapamayacak olduğumuz gibi tekrar tanımlamak zorunda kalırdık. Tekrar aynı şeyi
bu kadar temel bir algoritma ve tür için yazmanın anlamı yok. Örneği kalıpları kullanarak yeniden ele alalım</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kalıp</span> <span class="n">dizi</span> <span class="n">x</span>
<span class="p">{</span>
  <span class="n">hacim</span>   <span class="n">tam</span><span class="p">;</span>
  <span class="n">boyut</span>   <span class="n">tam</span><span class="p">;</span>
  <span class="n">İçerik</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dizi</span> <span class="n">dizi</span><span class="s1">&#39;x</span>
<span class="n">sanal</span> <span class="n">iş</span>
<span class="n">Yapılandır</span> <span class="n">hacim</span> <span class="n">tam</span>
<span class="p">{</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">hacim</span>  <span class="o">=</span> <span class="n">hacim</span><span class="p">;</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">boyut</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Dizi</span><span class="o">.</span><span class="n">İçerik</span> <span class="o">=</span> <span class="n">temiz</span><span class="p">(</span><span class="o">%*</span><span class="n">Dizi</span><span class="o">.</span><span class="n">Öğe</span><span class="p">[</span><span class="n">hacim</span><span class="p">]);</span>
  <span class="o">//%</span> <span class="n">işlemiyle</span> <span class="n">tür</span> <span class="n">alıyoruz</span> <span class="n">ki</span> <span class="n">tür</span> <span class="n">belirlendiğinde</span> <span class="n">hesabı</span> <span class="n">tutulabilsin</span><span class="o">.</span>
<span class="p">}</span>

<span class="n">Dizi</span> <span class="n">dizi</span><span class="s1">&#39;x</span>
<span class="n">sanal</span> <span class="n">iş</span>
<span class="n">Topla</span> <span class="n">toplanacakSayı</span> <span class="n">x</span>
<span class="p">{</span>
  <span class="n">her</span> <span class="n">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">boyut</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">:</span>
    <span class="n">Dizi</span><span class="o">-&gt;</span><span class="n">İçerik</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">toplanacakSayı</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">çağrı</span> <span class="n">örneği</span><span class="p">:</span>
<span class="n">iş</span> <span class="n">Giriş</span> <span class="n">argümanSayısı</span> <span class="n">tam</span><span class="p">,</span> <span class="n">_argümanlar</span> <span class="o">**</span><span class="n">t8</span>
<span class="p">{</span>
  <span class="n">değer</span> <span class="n">tamDizisi</span> <span class="n">dizi</span><span class="s1">&#39;ondalık;</span>
  <span class="n">dizi</span><span class="o">.</span><span class="n">Yapılandır</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="n">tamDizisi</span><span class="o">.</span><span class="n">Topla</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Özellikle bu konunun <strong>‘dizi’</strong> kalıbıyla anlatmayı seçtim zira bu kalıp o kadar temel ve o kadar çok kullanılan
bir kalıp ki C’de ne kadar çok dizilerle ilgili aynı işlemi yazdım sayısını unuttum.</p>
</section>
</section>
</section>
</div>
</section>
<span id="document-bolumler/acemi_ocagı"></span><section id="acemi-ocagi">
<h2>Acemi Ocağı<a class="headerlink" href="#acemi-ocagi" title="Bu başlık için kalıcı bağlantı">#</a></h2>
</section>
<span id="document-bolumler/algoritmalar"></span><section id="algoritmalar">
<h2>Algoritmalar<a class="headerlink" href="#algoritmalar" title="Bu başlık için kalıcı bağlantı">#</a></h2>
</section>
<span id="document-bolumler/unix_ortami"></span><section id="unix-ortami">
<h2>Unix Ortamı<a class="headerlink" href="#unix-ortami" title="Bu başlık için kalıcı bağlantı">#</a></h2>
</section>
<span id="document-bolumler/tasarım"></span><section id="tasarim">
<h2>Tasarım<a class="headerlink" href="#tasarim" title="Bu başlık için kalıcı bağlantı">#</a></h2>
</section>
</div>
<div class="admonition warning">
<p class="admonition-title">Uyarı</p>
<p>Daha hala hazırlık aşamasındayız. Bu illaki kötü bir şey olacak
diye bir kaide yok. Eğer yapıcı eleştirilerinizi iletirseniz
hazırlık aşamasında katkıda bulunabilir ve Örs dilinin gelişimine
kendi isteklerinizi de ekleyebilirsiniz.</p>
<p>İletişim için <a class="reference external" href="mailto:musakalayci&#37;&#52;&#48;gmail&#46;com">musakalayci<span>&#64;</span>gmail<span>&#46;</span>com</a> adresine yazarsanız, konusunu
belirtirseniz eleştirilerinizi mümkün olduğunca dikkate alabilirim.</p>
<p>Hatta önerileriniz varsa iletişim kanallarını açık tutarız ve
beraber sorunlara çözümler geliştirebiliriz.</p>
<p>Uslu çocuk olursak şirinleri bile görebiliriz.</p>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Arama Sayfası</span></a></p></li>
</ul>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By musakalayci<br/>
  
      &copy; Copyright 2022, musakalayci.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>